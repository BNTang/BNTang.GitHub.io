{"title":"『Java 语法基础』对 equals() 和 hashCode() 的理解","date":"2024-03-17T10:47:20.000Z","date_formatted":{"ll":"Mar 17, 2024","L":"03/17/2024","MM-DD":"03-17"},"link":"2024/03/17/面试题/Java/Java 基础/05-『Java 语法基础』对 equals() 和 hashCode() 的理解","tags":["Java"],"updated":"2024-03-17T16:54:48.181Z","content":"<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202403/2105804-20240317184802236-1807827290.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p>为什么在重写 equals 方法的时候需要重写 hashCode 方法</p>\n</blockquote>\n<p>因为有强制的规范指定需要同时重写 hashcode 与 equals 方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>\n<p>在Java中，<code>equals()</code> 和 <code>hashCode()</code> 方法是 <code>Object</code> 类的两个非常重要的方法，它们用于比较对象的相等性以及计算对象的哈希码。</p>\n<p><code>equals()</code> 方法用于判断两个对象是否逻辑上相等，也就是两个对象的内容是否相同。它通常需要根据实际情况在子类中重写，以提供正确的相等性逻辑。默认情况下（如 Object 类中的实现），<code>equals()</code> 方法比较对象的内存地址，也就是说，只有同一个对象才被认为是相等的。</p>\n<p><code>hashCode()</code> 方法则用于计算对象的哈希码，它被用于散列数据结构，如 <code>HashSet</code>、<code>HashMap</code> 等。在散列数据结构中，对象的哈希码通常被用来决定对象应该存放的位置。</p>\n<p>根据 Java 规范，有关 <code>equals()</code> 和 <code>hashCode()</code> 的重要契约包括：</p>\n<ol>\n<li>如果两个对象相等，那么它们的 <code>hashCode()</code> 方法必须返回相同的整数。</li>\n<li>如果两个对象的 <code>hashCode()</code> 方法返回相同的整数，这并不要求它们一定相等，但散列表的效率可能受到影响。</li>\n</ol>\n<p>之所以在重写 <code>equals()</code> 方法时必须同时重写 <code>hashCode()</code> 方法，是为了维持这两个方法之间的一致性。如果两个对象是相等的，但它们的哈希码不相同，这将违反 <code>hashCode()</code> 方法的契约，可能导致无法正确地存取散列数据结构中的对象。例如，在使用 <code>HashMap</code> 时，如果两个键对象相等，它们必须具有相同的哈希码，否则可能会导致其中一个对象无法被正确地找到。</p>\n<blockquote>\n<p>有没有可能两个不相等的对象有相同的 hashcode?</p>\n</blockquote>\n<p>有可能，即使两个对象不相同，它们也可能具有相同的 <code>hashCode</code> 值，这称为哈希冲突。哈希冲突是散列算法的一个固有属性，因为散列码是将对象信息映射到一个有限的整数域上。由于这个整数域范围的限制，相对于可能的对象状态来说是不足够的，从而导致不同对象间的哈希值可能相同。</p>\n<p>Java语言规范中关于 <code>hashCode</code> 的合同确实指出，如果两个对象相同，则它们的哈希码一定相同，但并未规定不同的对象必须产生不同的哈希码。因此，在基于哈希的数据结构中，如 <code>HashMap</code>，便可能出现哈希碰撞。在这种情况下，<code>HashMap</code> 会使用 <code>链表</code> 或 <code>红黑树</code> 来管理相同哈希码的不同键，确保了即便发生了哈希碰撞，也能通过 <code>equals()</code> 方法准确地区分和处理这些键。</p>\n<p>因此，为了确保诸如 <code>HashMap</code>、<code>HashSet</code> 这样的基于哈希的集合能够正确且高效地运作，合理地实现 <code>hashCode</code> 和 <code>equals</code> 方法以及妥善处理哈希冲突是至关重要的。</p>\n<blockquote>\n<p>两个相同的对象会有不同的 hash code 吗?</p>\n</blockquote>\n<p>不能，根据 hash code 的规定，这是不可能的。</p>\n<p>在 Java 中，当你重写一个类的 <code>equals()</code> 方法时，根据 Java 的规范，你也必须重写 <code>hashCode()</code> 方法，以保证同一个类的两个相等的对象（即 <code>equals()</code> 方法返回 <code>true</code>）返回相同的 hash code 值。这是因为 Java 中的集合类，如 <code>HashMap</code> 和 <code>HashSet</code>，依赖于 <code>hashCode()</code> 和 <code>equals()</code> 方法来确定对象的唯一性。</p>\n<p>如果两个对象根据 <code>equals(Object)</code> 方法是相等的，那么它们的 <code>hashCode()</code>方 法也必须返回相同的整数值。如果没有重写 <code>hashCode()</code>，那么默认的 <code>Object</code> 类的实现将产生基于对象内存地址的 hash code，这可能会违反这一规定，并且在使用哈希表的过程中导致性能下降。所以重写 <code>equals()</code> 时一定要同步重写 <code>hashCode()</code>，以确保行为的一致性。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202312/2105804-20231211215004818-977875224.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"『Java 语法基础』final、finalize 和 finally 的不同之处","link":"2024/03/17/面试题/Java/Java 基础/06-『Java 语法基础』final、finalize 和 finally 的不同之处"},"next":{"title":"『Java 语法基础』能在 Switch 中使用 String 吗？","link":"2024/03/17/面试题/Java/Java 基础/04-『Java 语法基础』能在 Switch 中使用 String 吗"},"plink":"http://example.com/2024/03/17/面试题/Java/Java 基础/05-『Java 语法基础』对 equals() 和 hashCode() 的理解/","reading_time":"1069 words in 7 min"}
{"title":"『Java 语法基础』final、finalize 和 finally 的不同之处","date":"2024-03-17T11:25:37.000Z","date_formatted":{"ll":"Mar 17, 2024","L":"03/17/2024","MM-DD":"03-17"},"link":"2024/03/17/面试题/Java/Java 基础/06-『Java 语法基础』final、finalize 和 finally 的不同之处","tags":["Java"],"updated":"2024-03-17T17:00:28.794Z","content":"<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202403/2105804-20240317233906001-177217684.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"final\">final<a title=\"#final\" href=\"#final\"></a></h1>\n<p>final 是一个修饰符，是 Java 编程语言中的一个关键字，可以用来修饰变量、方法、以及类。使用 <code>final</code> 的效果是不同的，取决于它修饰的对象类型。下面我会分别解释 <code>final</code> 修饰变量、方法和类时的效果。</p>\n<blockquote>\n<p>final 修饰变量</p>\n</blockquote>\n<p>当 <code>final</code> 修饰一个变量时，这个变量就变成了一个常量，也就是说它的值只能被赋值一次，一旦赋值之后就不能被修改了。如果尝试修改 <code>final</code> 变量的值，编译器会报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">number</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 初始化 final 变量</span><br><span class=\"hljs-comment\">// number = 15; // 编译错误，不能修改 final 变量的值</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>final 修饰方法</p>\n</blockquote>\n<p>当 <code>final</code> 修饰一个类的方法时，这个方法不能被子类覆盖或重写。这意味着子类不能提供一个具有相同名称和参数类型的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parent</span> &#123;<br>    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;这是一个 final 方法。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Parent</span> &#123;<br>    <span class=\"hljs-comment\">// 编译错误，不能覆盖 final 方法</span><br>    <span class=\"hljs-comment\">// void show() &#123;</span><br>    <span class=\"hljs-comment\">//     System.out.println(&quot;尝试覆盖 final 方法。&quot;);</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>final 修饰类</p>\n</blockquote>\n<p>当 <code>final</code> 修饰一个类时，表示这个类不能被继承。换句话说，没有其他类能够继承 final 类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FinalClass</span> &#123;<br>    <span class=\"hljs-comment\">// 类的定义</span><br>&#125;<br><br><span class=\"hljs-comment\">// 编译错误，不能继承 final 类</span><br><span class=\"hljs-comment\">// class SubClass extends FinalClass &#123;</span><br><span class=\"hljs-comment\">// &#125;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"finalize\">finalize<a title=\"#finalize\" href=\"#finalize\"></a></h1>\n<p><code>finalize()</code> 方法在 Java 中是与对象生命周期关联的一个概念。当一个对象不再有任何的引用指向它，也就是说，这个对象不再被程序中的其他部分所需要时，Java 虚拟机（JVM）的垃圾收集器（GC）可能会考虑将其回收以释放内存资源。在垃圾收集器决定回收对象之前，<code>finalize()</code> 方法会被调用，给予了这个对象一个机会来进行清理工作，比如关闭打开的资源等。</p>\n<p>然而，<code>finalize()</code> 方法存在几个问题：</p>\n<ol>\n<li>不确定性：<code>finalize()</code> 方法被调用的具体时间是不确定的。垃圾收集器运行的时间取决于多种因素，包括 JVM 的内存使用情况、垃圾收集算法等。这意味着，从对象不再有引用到 <code>finalize()</code> 方法被调用之间的时间可能非常长，甚至可能永远不会被调用。</li>\n<li>性能问题：由于 <code>finalize()</code> 执行不确定，且可能影响垃圾收集的效率，过度依赖 <code>finalize()</code> 方法可能会导致性能问题，例如延迟对象内存的回收，或导致内存泄漏。</li>\n<li>资源释放：如果你在 <code>finalize()</code> 方法中处理类似于文件关闭等操作，可能会导致资源无法及时释放。如果你的应用程序打开了大量文件且依赖于 <code>finalize()</code> 方法来关闭这些文件，可能会导致资源耗尽，因为垃圾收集器没有及时调用 <code>finalize()</code> 方法。</li>\n</ol>\n<p>因此，通常的最佳实践是避免使用 <code>finalize()</code> 方法来清理资源。相反，推荐使用 try-with-resources 语句或者显式的清理方法，例如，在你控制资源的代码块中使用 try-catch-finally 来确保资源始终得到适当的释放。</p>\n<p>简而言之，<code>finalize()</code> 方法可以看作是在对象生命周期结束前的 “最后通牒”，虽然你可以在这里做一些清理工作，但它的执行是不可预测的，并且可能会给程序带来更多问题，因此不建议依赖它来释放资源或做其他关键操作。</p>\n<h1 id=\"finally\">finally<a title=\"#finally\" href=\"#finally\"></a></h1>\n<p>finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>\n<p>想象一下，你在游乐场玩抛球游戏。<code>try</code> 块就像是你向篮筐投球的尝试，如果球进了篮筐，那就意味着没有发生错误，你的代码运行正常。而如果球没有进篮筐，这就好比发生了异常，这时候 <code>catch</code> 块就会介入，像是游戏工作人员过来告诉你什么出了问题，并给你另一次机会。</p>\n<p>现在，打个比方，无论你是否成功将球投入篮筐（即无论 <code>try</code> 块中的代码是否成功运行），你都必须将球还给工作人员，这个动作就像是 <code>finally</code> 块。<code>finally</code> 块确保了无论之前发生了什么，一些必须进行的清理工作（比如归还球）都会被执行。这表示即便在 <code>try</code> 块中代码顺利执行或 <code>catch</code> 块捕获到异常后运行相应的错误处理代码，<code>finally</code> 块中的代码也总是会被执行。这通常是用来释放资源，比如关闭文件流或数据库连接。</p>\n<p>简言之，<code>finally</code> 是你整理游戏场地，确保一切都已妥善处理后才离开的保障。它保证了，在你完成游戏之后，不管结果如何，都会有一些后处理工作被执行以维持场地的正常运作。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202312/2105804-20231211215004818-977875224.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"『Java 语法基础』String、StringBuffer 与 StringBuilder 的区别","link":"2024/03/18/面试题/Java/Java 基础/07-『Java 语法基础』String、StringBuffer 与 StringBuilder 的区别"},"next":{"title":"『Java 语法基础』对 equals() 和 hashCode() 的理解","link":"2024/03/17/面试题/Java/Java 基础/05-『Java 语法基础』对 equals() 和 hashCode() 的理解"},"plink":"http://example.com/2024/03/17/面试题/Java/Java 基础/06-『Java 语法基础』final、finalize 和 finally 的不同之处/","toc":[{"id":"final","title":"final","index":"1"},{"id":"finalize","title":"finalize","index":"2"},{"id":"finally","title":"finally","index":"3"}],"reading_time":"1308 words in 9 min"}
{"title":"代码质量-开闭原则","date":"2023-11-25T18:24:06.000Z","date_formatted":{"ll":"Nov 26, 2023","L":"11/26/2023","MM-DD":"11-26"},"link":"2023/11/26/设计模式/04-代码质量-开闭原则","tags":["设计模式"],"updated":"2023-11-25T18:59:52.418Z","content":"<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>什么是开闭原则？</p>\n<ul>\n<li>开闭原则（Open-Closed Principle, OCP）是 <code>面向对象</code> 设计中的一个重要原则。</li>\n<li>它指出软件实体（如类、模块、函数等）应该对扩展开放，对修改封闭。这意味着一个实体允许其行为被扩展，但不允许修改其源代码。</li>\n</ul>\n<h1 id=\"不遵循开闭原则的代码示例\">不遵循开闭原则的代码示例<a title=\"#不遵循开闭原则的代码示例\" href=\"#不遵循开闭原则的代码示例\"></a></h1>\n<p>假设有一个简单的类，用于根据不同的形状类型绘制图形。如果要添加新的形状类型，需要修改已有的代码。</p>\n<p>代码在：<a href=\"https://github.com/BNTang/code-quality/tree/main/src/main/java/top/it6666/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/%E4%B8%8D%E9%81%B5%E5%BE%AA%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\" target=\"_blank\">https://github.com/BNTang/code-quality/tree/main/src/main/java/top/it6666/开闭原则/不遵循开闭原则的代码示例</a></p>\n<h1 id=\"遵循开闭原则的代码示例\">遵循开闭原则的代码示例<a title=\"#遵循开闭原则的代码示例\" href=\"#遵循开闭原则的代码示例\"></a></h1>\n<p>改进后的代码使用 <code>多态</code> 和 <code>继承</code> 来允许新的形状类型的添加，而不需要修改现有代码。</p>\n<p>代码在：<a href=\"https://github.com/BNTang/code-quality/tree/main/src/main/java/top/it6666/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/%E9%81%B5%E5%BE%AA%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\" target=\"_blank\">https://github.com/BNTang/code-quality/tree/main/src/main/java/top/it6666/开闭原则/遵循开闭原则的代码示例</a></p>\n<p>在这个遵循开闭原则的版本中，<code>GraphicEditor</code> 不需要知道具体的形状类型。它只调用 <code>Shape</code> 类中的 <code>draw()</code> 方法。这样，添加新的形状类型时，只需要扩展 <code>Shape</code> 类并实现 <code>draw()</code> 方法，而不需要修改 <code>GraphicEditor</code> 或其他形状类的代码。这就是遵循开闭原则的设计。</p>\n<h1 id=\"解决方案\">解决方案<a title=\"#解决方案\" href=\"#解决方案\"></a></h1>\n<blockquote>\n<p>遵循开闭原则的其他解决方案通常涉及使用设计模式，这些模式能够提供灵活性和扩展性，同时保持现有代码的稳定性。</p>\n</blockquote>\n<p>以下是一些常见的设计模式和技术，它们有助于实现开闭原则:</p>\n<ul>\n<li>策略模式（Strategy Pattern）</li>\n<li>工厂模式（Factory Pattern）</li>\n<li>模板方法模式（Template Method Pattern）</li>\n<li>装饰器模式（Decorator Pattern）</li>\n<li>依赖倒置原则（Dependency Inversion Principle）</li>\n</ul>\n<p>通过采用这些设计模式和原则，可以创建灵活且可维护的软件系统，使得新功能的添加或现有功能的变更，不会破坏或过多地修改现有的代码结构。这些方法都是为了达到“对扩展开放，对修改封闭”的目标。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231122231128423-999760020.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"代码质量-单一职责","link":"2023/11/26/设计模式/06-代码质量-单一职责"},"next":{"title":"UML 知识点梳理","link":"2023/11/25/UML/01-UML 知识点梳理"},"plink":"http://example.com/2023/11/26/设计模式/04-代码质量-开闭原则/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"不遵循开闭原则的代码示例","title":"不遵循开闭原则的代码示例","index":"2"},{"id":"遵循开闭原则的代码示例","title":"遵循开闭原则的代码示例","index":"3"},{"id":"解决方案","title":"解决方案","index":"4"}],"reading_time":"550 words in 4 min"}
{"title":"手撕Vuex-提取模块信息","date":"2023-11-05T02:39:54.000Z","date_formatted":{"ll":"Nov 5, 2023","L":"11/05/2023","MM-DD":"11-05"},"link":"2023/11/05/手写VueX/09-手撕Vuex-提取模块信息","tags":["手写Vuex"],"updated":"2023-11-18T01:27:18.716Z","content":"<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231118092716215-70706076.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>在上一篇【手撕Vuex-模块化共享数据】文章中，已经了解了模块化，与共享数据的注意点。</p>\n<p>那么接下来就要在我们自己的 Nuex 中实现共享数据模块化的功能。那么怎么在我们自己的 Nuex 中实现共享数据模块化的功能呢？</p>\n<h1 id=\"处理数据\">处理数据<a title=\"#处理数据\" href=\"#处理数据\"></a></h1>\n<p>也非常的简单，是不是就是处理一下子模块的数据，处理一下子模块的 getters，处理下子模块的 mutations，处理下子模块的 actions 就可以了。</p>\n<p>那么怎么处理呢？首先我们来看下数据怎么处理。想要知道怎么处理的，我们首先要知道数据是怎么使用的。</p>\n<p>数据怎么使用的，我们在组件当中是不是拿到全局的 Store, 拿到全局的 Store 之后，从全局的 store 中拿到子模块，然后从子模块中拿到数据，然后在组件当中使用。</p>\n<p>所以说我需要怎么做，我们需要将子模块的一个数据添加到全局的 Store 当中，好了到这里我们就已经了解了数据怎么处理了。</p>\n<p>那么接下来我们就来看下 getters/ mutations/ actions 怎么处理。</p>\n<h1 id=\"处理-getters\">处理 getters<a title=\"#处理-getters\" href=\"#处理-getters\"></a></h1>\n<p>处理 getters 首先第一条就是，重名的方法不能不进行覆盖。</p>\n<h1 id=\"处理-mutations\">处理 mutations<a title=\"#处理-mutations\" href=\"#处理-mutations\"></a></h1>\n<p>处理 mutations，在 mutations 当中，出现了同名的方法，那么就不能不进行覆盖。</p>\n<p>如果说出现了同名的方法，那么取值就是一个数组，将所有的同名方法都添加到这个数组当中。</p>\n<p>然后执行这个同名方法就是循环这个数组，然后执行这个数组当中的每一个方法。</p>\n<h1 id=\"处理-actions\">处理 actions<a title=\"#处理-actions\" href=\"#处理-actions\"></a></h1>\n<p>处理 actions，如果说出现了同名的方法，那么取值就是一个数组，将所有的同名方法都添加到这个数组当中(同理可证)。</p>\n<p>那么知道了怎么处理了之后，接下来怎么办呢？我们就来看下代码怎么写。如果我们直接处理传递进来的数据，可能呢，会比较麻烦，所以说在处理之前呢，我还需要将传递进来的数据进行一下子处理，按照我想要的格式进行格式化一下。</p>\n<h1 id=\"格式化数据\">格式化数据<a title=\"#格式化数据\" href=\"#格式化数据\"></a></h1>\n<p>在实现之前，我先将我想格式的数据结构贴出来按照这个结构去编写我们的格式化数据的方法。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">let root = &#123;<br>    _raw: rootModule,<br>    _state: rootModule.state,<br>    _children: &#123;<br>        home: &#123;<br>            _raw: homeModule,<br>            _state: homeModule.state,<br>            _children: &#123;&#125;<br>        &#125;,<br>        account: &#123;<br>            _raw: accountModule,<br>            _state: accountModule.state,<br>            _children: &#123;<br>                login: &#123;<br>                    _raw: loginModule,<br>                    _state: loginModule.state,<br>                    _children: &#123;&#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>那么我们就来看下怎么实现这个方法。</p>\n<p>由于实现的方法代码比较绕，所以我这里单独开了一个类，来处理这件事情。</p>\n<p>这个类的名字叫做 ModuleCollection，这个类的作用就是将传递进来的数据进行格式化，然后返回一个格式化之后的数据。</p>\n<p>到这里就要步入正题了，我们就来看下这个类的代码怎么写。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231106235938379-1215720548.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>首先在 Store 类当中，将传递进来的数据传递到 ModuleCollection 类当中，然后在 ModuleCollection 类当中，将传递进来的数据进行格式化，然后返回一个格式化之后的数据。</p>\n<p>编写 ModuleCollection 类的代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ModuleCollection</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">options</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">register</span>([], options);<br>    &#125;<br><br>    <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\">arr, rootModule</span>) &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>首先通过构造函数接收传递进来的数据，然后在构造函数当中，调用 register 方法，将传递进来的数据传递进去。</p>\n<p>然后在 register 方法当中，接收两个参数，第一个参数是一个数组，第二个参数是一个对象。</p>\n<p>第一个参数是一个数组，这个数组是用来存储模块的名字的，第二个参数是一个对象，这个对象是用来存储模块的数据的。</p>\n<p>第一个参数是数组也是我想用来区分是根模块还是子模块的，如果说是根模块，那么这个数组就是空的，如果说是子模块，那么这个数组就是有值的。</p>\n<p>好了我们继续走，第一步要处理的就是按照我们需要的格式创建模块，我定义了一个对象 module：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable language_\">module</span> = &#123;<br>    <span class=\"hljs-attr\">_raw</span>: rootModule,<br>    <span class=\"hljs-attr\">_state</span>: rootModule.<span class=\"hljs-property\">state</span>,<br>    <span class=\"hljs-attr\">_children</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如上虽然定义了模块信息但是还没有进行存储起来，所以我们的第二步就是保存模块信息。</p>\n<p>首先我将根模块进行存储起来，子模块我们稍后再说。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 2.保存模块信息</span><br><span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">// 保存根模块</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">root</span> = <span class=\"hljs-variable language_\">module</span>;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// 保存子模块</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>注意一下我所说的内容，我只是将根模块进行存储起来，子模块还没有进行存储起来。</p>\n<p>好，到这里我们的第二部先告一段落，接下来我们就来看下第三步怎么做。</p>\n<p>第三步就是处理子模块，我们先来看下怎么处理子模块。</p>\n<p>首先我们要知道子模块的名字，这个可以通过循环根模块的 modules 属性来获取。知道了子模块的名称之后，我们就可以通过子模块的名称来获取子模块的数据。从根模块的 modules 属性当中通过子模块的名称来获取子模块的数据。</p>\n<p>随后我们就可以通过子模块的数据来创建子模块的模块信息，然后将子模块的模块信息进行存储起来。</p>\n<p>我们先将第三步的内容完成，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> childrenModuleName <span class=\"hljs-keyword\">in</span> rootModule.<span class=\"hljs-property\">modules</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> childrenModule = rootModule.<span class=\"hljs-property\">modules</span>[childrenModuleName];<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">register</span>(arr.<span class=\"hljs-title function_\">concat</span>(childrenModuleName), childrenModule)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如上代码的含义是，首先通过 for in 循环遍历根模块的 modules 属性，然后通过子模块的名称来获取子模块的数据，然后通过子模块的数据来创建子模块的模块信息，然后将子模块的模块信息进行存储起来。</p>\n<p>这里就直接递归调用 register 方法，将子模块的名称和子模块的数据传递进去。并且在递归调用的时候，将子模块的名称添加到 arr 数组当中。目的就是为了区分是根模块还是子模块。也是为了方便我们后续的操作（保存子模块）。</p>\n<p>好了到这里我们的第三步也完成了，我们先将 arr 数组进行打印，看下 arr 数组的内容是什么。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231107235825218-1568231942.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>❗️注意：记得将官方的 Vuex 注释掉，用我们自己的不然你会发现打印的内容和我们自己的不一样。</p>\n<p>打印结果如下图：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231107235926079-1297741990.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p><code>[]</code> 代表的是根模块，<code>[home]</code> 代表的是 home 模块，<code>[account]</code> 代表的是 account 模块，<code>[account, login]</code> 代表的是 account 模块下的 login 模块。</p>\n<p>好了到这里我们的第三步也完成了，接下来我们就来看下之前第二步没有完成的内容怎么完成。</p>\n<p>基于第三步的打印结果分析出来各个模块的关系就可以根据这个关系得出各个模块的父子关系。按照这个关系就可以将子模块的模块信息进行存储起来。</p>\n<p>我们先来看下代码怎么写，其实非常简单我们先来分析一下，只需要分析 <code>[account, login]</code> 这种情况即可，我还是先将这种场景先不直接就给出答案，我们循序渐进的来，我们就走普通的逻辑，然后再来看下代码怎么写。我会直接往根模块的 children 属性当中添加子模块的模块信息。子模块信息已经通过参数传递进来了，所以说我只需要将子模块的名称获取到即可，根据之前打印的结果来看，子模块的名称是 arr 数组当中的最后一个元素，所以说我只需要获取 arr 数组当中的最后一个元素即可。</p>\n<p>然后将子模块的名称作为 key，子模块的模块信息作为 value，添加到根模块的 children 属性当中即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">root</span>.<span class=\"hljs-property\">_children</span>[arr[arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>]] = <span class=\"hljs-variable language_\">module</span>;<br></code></pre></td></tr></table></figure>\n<p>好了到这里我们的第二步也完成了，我们高高兴兴的要去打印结果了，结果如下：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231108000808213-1780130303.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>发现 login 模块在 root 的 children 属性当中了，login 模块应该在 account 模块的 children 属性当中，所以说我们的代码还是有问题的。</p>\n<p>诶，我们的代码有问题，那么我们就来看下问题出在哪里了。</p>\n<p>问题出在我们不能直接往根模块的 children 属性当中添加子模块的模块信息，我们应该往父模块的 children 属性当中添加子模块的模块信息。</p>\n<p>那么我们怎么知道父模块是谁呢？我们可以通过 root._children 来得到父模块，然后将子模块的模块信息添加到父模块的 children 属性当中即可。</p>\n<p>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> parent = arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">root, currentKey</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> root.<span class=\"hljs-property\">_children</span>[currentKey];<br>&#125;, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">root</span>);<br>parent.<span class=\"hljs-property\">_children</span>[arr[arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>]] = <span class=\"hljs-variable language_\">module</span>;<br></code></pre></td></tr></table></figure>\n<p>让我来逐步解释：</p>\n<ol>\n<li><code>let parent = arr.splice(0, arr.length - 1)</code>：这一行代码从数组 <code>arr</code> 中移除并返回除了最后一个元素之外的所有元素，将这些元素存储在 <code>parent</code> 变量中。</li>\n<li><code>.reduce((root, currentKey) =&gt; &#123; return root._children[currentKey]; &#125;, this.root)</code>：这是一个 <code>reduce</code> 函数调用，它逐个遍历 <code>parent</code> 数组中的元素。<code>root</code> 是累积的结果，初始值是 <code>this.root</code>。<code>currentKey</code> 是每次迭代中的当前元素。</li>\n<li><code>parent._children[arr[arr.length - 1]] = module</code>：最后一行代码将 <code>module</code> 赋值给 <code>parent</code> 对象的 <code>_children</code> 属性中的某个属性，该属性的名称来自数组 <code>arr</code> 的最后一个元素。</li>\n</ol>\n<p>如上是个简单的解释，接下来我套用数据来解释一下，如下：</p>\n<p>例如有这么一个父子结构模块的数组 <code>let testArr = ['account', 'login'];</code>，那么 <code>arr.splice(0, arr.length - 1)</code> 就是将 <code>testArr</code> 数组中的最后一个元素移除并返回除了最后一个元素之外的所有元素，将这些元素存储在 <code>parent</code> 变量中，那么 <code>parent</code> 变量中的值就是 <code>['account']</code>。</p>\n<p>然后 <code>reduce</code> 函数调用，它逐个遍历 <code>parent</code> 数组中的元素。<code>root</code> 是累积的结果，初始值是 <code>this.root</code>。<code>currentKey</code> 是每次迭代中的当前元素。那么 <code>root._children[currentKey]</code> 就是 <code>this.root._children['account']</code>，那么 <code>this.root._children['account']</code> 的值就是 <code>account</code> 模块的模块信息。</p>\n<p>最后一行代码将 <code>module</code> 赋值给 <code>parent</code> 对象的 <code>_children</code> 属性中的某个属性，该属性的名称来自数组 <code>arr</code> 的最后一个元素。那么 <code>parent._children[arr[arr.length - 1]]</code> 就是 <code>account</code> 模块的模块信息，然后将 <code>module</code> 赋值给 <code>account</code> 模块的子模块，这样我们的 login 模块就在 account 模块的 children 属性当中了。</p>\n<p>这个时候我们在来打印一下结果，结果如下：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231108005405973-204472737.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>好了这回就是我们想要的结果了，到此为止我们的 ModuleCollection 类就完成了。</p>\n","prev":{"title":"手撕Vuex-安装模块数据","link":"2023/11/08/手写VueX/10-手撕Vuex-安装模块数据"},"next":{"title":"手撕Vuex-模块化共享数据下","link":"2023/11/05/手写VueX/08-手撕Vuex-模块化共享数据上"},"plink":"http://example.com/2023/11/05/手写VueX/09-手撕Vuex-提取模块信息/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"处理数据","title":"处理数据","index":"2"},{"id":"处理-getters","title":"处理 getters","index":"3"},{"id":"处理-mutations","title":"处理 mutations","index":"4"},{"id":"处理-actions","title":"处理 actions","index":"5"},{"id":"格式化数据","title":"格式化数据","index":"6"}],"reading_time":"2904 words in 19 min"}
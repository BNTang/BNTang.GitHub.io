{"title":"手撕Vuex-模块化共享数据下","date":"2023-11-05T01:36:04.000Z","date_formatted":{"ll":"Nov 5, 2023","L":"11/05/2023","MM-DD":"11-05"},"link":"2023/11/05/手写VueX/08-手撕Vuex-模块化共享数据上","tags":["手写Vuex"],"updated":"2023-11-05T04:12:47.907Z","content":"<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>好，经过上一篇的介绍，了解了 Vuex 当中的模块化，本章主要介绍 Vuex 当中的模块化共享数据下篇。</p>\n<p>我们知道在全局的 Store 对象当中，我们可以定义全局的数据，那么如果我们在模块当中也定义了一个属性名称和全局的属性名称相同，那么会发生什么呢？</p>\n<p>我们先来看看，在全局当中定义了一个 globalName 属性，然后在模块当中也定义了一个 globalName 属性：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231105094344864-771792939.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>展示一下模块化当中的 globalName 属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;p&gt;&#123;&#123; this.$store.state.home.globalName &#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure>\n<p>运行项目，查看控制台是没有任何错误信息的，说明在模块当中定义与全局相同的属性名称是没有问题的。</p>\n<p>看了共享数据，接下来我们来看看 getters/mutations/actions 能不能定义与全局相同的方法呢？</p>\n<h1 id=\"getters\">getters<a title=\"#getters\" href=\"#getters\"></a></h1>\n<p>我们先来看看 getters，我们在全局当中定义了一个 getGlobalName 方法，然后在模块当中也定义了一个 getGlobalName 方法：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231105094651562-1631412512.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>返回浏览器，查看控制台输出了一个错误信息：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">[vuex] duplicate getter key: getGlobalName<br></code></pre></td></tr></table></figure>\n<p>说明在模块当中定义与全局相同的 getters 方法是不行的。</p>\n<p>❗️注意：<code>多个模块中不能出现同名的getters方法</code>。</p>\n<h1 id=\"mutations\">mutations<a title=\"#mutations\" href=\"#mutations\"></a></h1>\n<p>看了 getters，接下来我们来看看 mutations 能不能定义与全局相同的方法呢？</p>\n<p>我们在全局当中定义了一个 changeGlobalName 方法，然后在模块当中也定义了一个 changeGlobalName 方法。</p>\n<p>全局：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">changeGlobalName</span>(<span class=\"hljs-params\">state, payload</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;全局中的changeGlobalName&quot;</span>);<br>    state.<span class=\"hljs-property\">globalName</span> += payload;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">changeGlobalName</span>(<span class=\"hljs-params\">state, payload</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;home中的changeGlobalName&quot;</span>);<br>    state.<span class=\"hljs-property\">globalName</span> += payload;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>返回浏览器，点击全局模块的按钮，查看控制台输出, 发现输出了两次：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231105102700189-710397514.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>说明在模块当中定义与全局相同的 mutations 方法是可以的。</p>\n<p>❗️注意：</p>\n<ul>\n<li>多个模块的mutations中可以出现同名的方法</li>\n<li>多个同名的方法不会覆盖, 会放到数组中然后依次执行</li>\n</ul>\n<h1 id=\"actions\">actions<a title=\"#actions\" href=\"#actions\"></a></h1>\n<p>看了 mutations，接下来我们来看看 actions 能不能定义与全局相同的方法呢？</p>\n<p>我们在全局当中定义了一个 asyncChangeGlobalName 方法，然后在模块当中也定义了一个 asyncChangeGlobalName 方法。</p>\n<p>全局：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">asyncChangeGlobalName</span>(<span class=\"hljs-params\">&#123;commit&#125;, payload</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;全局中的asyncChangeGlobalName&quot;</span>);<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-title function_\">commit</span>(<span class=\"hljs-string\">&#x27;changeGlobalName&#x27;</span>, payload);<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">asyncChangeGlobalName</span>(<span class=\"hljs-params\">&#123;commit&#125;, payload</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;home中的asyncChangeGlobalName&quot;</span>);<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-title function_\">commit</span>(<span class=\"hljs-string\">&#x27;changeGlobalName&#x27;</span>, payload);<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>返回浏览器，点击全局模块的按钮，查看控制台输出, 发现输出了两次：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202311/2105804-20231105103200187-270347307.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>说明在模块当中定义与全局相同的 actions 方法是可以的。</p>\n<p>❗️注意：</p>\n<ul>\n<li>多个模块的actions中可以出现同名的方法</li>\n<li>多个同名的方法不会覆盖, 会放到数组中然后依次执行</li>\n</ul>\n<h1 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h1>\n<p>好了，这里我们就知道了在模块化当中，如果定义了与全局相同的属性名称，是没有问题的，但是如果定义了与全局相同的 getters 方法，那么就会报错，但是如果定义了与全局相同的 mutations/actions 方法，那么就会将这些方法放到一个数组当中，然后依次执行。</p>\n<p>知道了这些之后，我们就可以实现 module 模块化了。</p>\n","prev":{"title":"手撕Vuex-提取模块信息","link":"2023/11/05/手写VueX/09-手撕Vuex-提取模块信息"},"next":{"title":"Vite 前期过渡","link":"2023/11/04/Vite/前期过度/01-Vite 前期过渡"},"plink":"http://example.com/2023/11/05/手写VueX/08-手撕Vuex-模块化共享数据上/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"getters","title":"getters","index":"2"},{"id":"mutations","title":"mutations","index":"3"},{"id":"actions","title":"actions","index":"4"},{"id":"总结","title":"总结","index":"5"}],"reading_time":"881 words in 6 min"}
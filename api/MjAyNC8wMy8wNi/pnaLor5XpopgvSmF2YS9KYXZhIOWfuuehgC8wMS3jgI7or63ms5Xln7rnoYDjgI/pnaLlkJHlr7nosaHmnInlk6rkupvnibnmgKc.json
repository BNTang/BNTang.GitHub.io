{"title":"『Java 语法基础』面向对象有哪些特性","date":"2024-03-06T12:43:53.000Z","date_formatted":{"ll":"Mar 6, 2024","L":"03/06/2024","MM-DD":"03-06"},"link":"2024/03/06/面试题/Java/Java 基础/01-『语法基础』面向对象有哪些特性","tags":["Java"],"updated":"2024-03-10T16:27:24.500Z","content":"<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202403/2105804-20240309090114418-1356491206.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p><code>面向对象编程（OOP）</code> 是一个将现实世界抽象为一系列对象的编程范式，这些对象通过消息传递机制来互相交流和协作。</p>\n<p>OOP 的主要特性包括四个基本概念：<code>封装</code>（Encapsulation）、<code>继承</code>（Inheritance）、<code>多态</code>（Polymorphism）以及<code>抽象</code>（Abstraction）。</p>\n<h1 id=\"封装（encapsulation）\">封装（Encapsulation）<a title=\"#封装（encapsulation）\" href=\"#封装（encapsulation）\"></a></h1>\n<p>封装是一种将数据（<code>属性</code>）和行为（<code>方法</code>）绑定在一起的方法。</p>\n<p>通过封装，可以隐藏对象的具体实现细节，仅暴露出有限的接口供外界访问。</p>\n<h2 id=\"优势\">优势<a title=\"#优势\" href=\"#优势\"></a></h2>\n<p>封装的优势：</p>\n<ul>\n<li><strong>增强安全性</strong>：隐藏内部实现细节，防止外部直接访问对象内部的数据，减少因误用导致的错误</li>\n</ul>\n<p>这里我编写了一个 <code>UserCredentials</code> 类，来进行演示一下 <code>增强安全性</code>，分别体现在什么地方，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> BNTang</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@description</span> 用户凭证类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserCredentials</span> &#123;<br>    <span class=\"hljs-comment\">// 私有属性，外部无法直接访问</span><br>    <span class=\"hljs-keyword\">private</span> String username;<br>    <span class=\"hljs-keyword\">private</span> String password;<br><br>    <span class=\"hljs-comment\">// 公有的构造函数，用于初始化用户名和密码</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">UserCredentials</span><span class=\"hljs-params\">(String username, String password)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.username = username;<br>        <span class=\"hljs-built_in\">this</span>.password = password;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 公有的方法，用于验证密码是否正确</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">authenticate</span><span class=\"hljs-params\">(String inputPassword)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> inputPassword != <span class=\"hljs-literal\">null</span> &amp;&amp; inputPassword.equals(<span class=\"hljs-built_in\">this</span>.password);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获得用户名的公有方法</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getUsername</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.username;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 重置密码的方法，增加安全性校验</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">resetPassword</span><span class=\"hljs-params\">(String oldPassword, String newPassword)</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (authenticate(oldPassword)) &#123;<br>            <span class=\"hljs-built_in\">this</span>.password = newPassword;<br>            System.out.println(<span class=\"hljs-string\">&quot;密码重置成功。&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;旧密码不正确，密码重置失败。&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 私有的设置密码方法，外部无法访问</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setPassword</span><span class=\"hljs-params\">(String password)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.password = password;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在我提供的 <code>UserCredentials</code> 类的代码中，隐藏内部实现细节、防止外部直接访问对象内部的数据以及减少因误用导致的错误的概念都得到了实现。</p>\n<ol>\n<li><strong>隐藏内部实现细节</strong>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setPassword</span><span class=\"hljs-params\">(String password)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.password = password;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>setPassword</code> 方法是私有的 (<code>private</code>)，意味着它只能在类内部被调用。外部代码不能直接调用此方法来设置密码，这正是隐藏内部实现细节的体现。</p>\n<ol start=\"2\">\n<li><strong>防止外部直接访问对象内部的数据</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> String username;<br><span class=\"hljs-keyword\">private</span> String password;<br></code></pre></td></tr></table></figure>\n<p>这段代码中，用户名 (<code>username</code>) 和密码 (<code>password</code>) 被声明为私有变量 (<code>private</code>)，这意味着它们不能从类的外部直接访问，只能通过类提供的公有方法（如构造方法、<code>getUsername</code>、<code>authenticate</code> 和 <code>resetPassword</code> 方法等）来间接访问或修改。这种机制有效地保护了类的内部数据。</p>\n<ol start=\"3\">\n<li><strong>减少因误用导致的错误</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">resetPassword</span><span class=\"hljs-params\">(String oldPassword, String newPassword)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (authenticate(oldPassword)) &#123;<br>        <span class=\"hljs-built_in\">this</span>.password = newPassword;<br>        System.out.println(<span class=\"hljs-string\">&quot;密码重置成功。&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;旧密码不正确，密码重置失败。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在 <code>resetPassword</code> 方法中，通过 <code>authenticate</code> 方法校验旧密码是否正确，只有在旧密码正确的情况下才允许用户设置新密码。这样的设计减少了因为外部代码错误使用（如直接设置密码而不进行旧密码验证）导致的安全问题，同时也确保了类内部数据的完整性和安全性。</p>\n<ul>\n<li><strong>提高复用性</strong>：封装后的对象可以作为一个黑盒被重复使用，无需关心对象内部的复杂逻辑</li>\n</ul>\n<ol>\n<li><strong>封装后的对象作为一个黑盒被重复使用体现在：</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">UserCredentials</span> <span class=\"hljs-variable\">adminCredentials</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UserCredentials</span>(<span class=\"hljs-string\">&quot;admin&quot;</span>, <span class=\"hljs-string\">&quot;adminPass&quot;</span>);<br><span class=\"hljs-type\">UserCredentials</span> <span class=\"hljs-variable\">userCredentials</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UserCredentials</span>(<span class=\"hljs-string\">&quot;user&quot;</span>, <span class=\"hljs-string\">&quot;userPass&quot;</span>);<br><br><span class=\"hljs-comment\">// 在不同场景中重复使用对象:</span><br><span class=\"hljs-keyword\">if</span> (adminCredentials.authenticate(<span class=\"hljs-string\">&quot;adminPass&quot;</span>)) &#123;<br>    <span class=\"hljs-comment\">// 执行管理员操作</span><br>&#125;<br><br><span class=\"hljs-keyword\">if</span> (userCredentials.authenticate(<span class=\"hljs-string\">&quot;userPass&quot;</span>)) &#123;<br>    <span class=\"hljs-comment\">// 执行用户操作</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>adminCredentials</code> 和 <code>userCredentials</code> 是 <code>UserCredentials</code> 的实例，在创建它们之后可以多次使用其 <code>authenticate</code> 方法来验证密码，这里的实例就像是提供认证功能的黑盒，使用者不必关心里面的逻辑是怎样的。</p>\n<ol start=\"2\">\n<li><strong>无需关心对象内部的复杂逻辑体现在</strong>  ：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> String username;<br><span class=\"hljs-keyword\">private</span> String password;<br><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setPassword</span><span class=\"hljs-params\">(String password)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.password = password;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>由于 <code>username</code>  和 <code>password</code> 属性被声明为私有的，外部代码不能直接访问或修改它们。设置密码的逻辑被隐藏在 <code>setPassword</code> 方法中，而这个方法也是私有的。外部代码需要通过公有方法如构造函数或 <code>resetPassword</code> 这些公有接口进行操作，因此外部代码不必关心如何存储或验证密码的内部逻辑，只需调用这些公有方法即可实现功能。</p>\n<ul>\n<li><strong>易于维护</strong>：封装的代码更易理解与修改，修改内部实现时不会影响到使用该对象的代码</li>\n</ul>\n<ol>\n<li><strong>封装的代码更易理解与修改体现在</strong>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">authenticate</span><span class=\"hljs-params\">(String inputPassword)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> inputPassword != <span class=\"hljs-literal\">null</span> &amp;&amp; inputPassword.equals(<span class=\"hljs-built_in\">this</span>.password);<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">resetPassword</span><span class=\"hljs-params\">(String oldPassword, String newPassword)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (authenticate(oldPassword)) &#123;<br>        <span class=\"hljs-built_in\">this</span>.password = newPassword;<br>        System.out.println(<span class=\"hljs-string\">&quot;密码重置成功。&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;旧密码不正确，密码重置失败。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在 <code>authenticate</code> 和 <code>resetPassword</code> 这两个公有方法中，封装的代码很易于理解：一个用于验证密码，一个用于重新设置密码。如果我们需要修改密码的存储逻辑，只需修改这些方法的内部逻辑，而无需修改方法的签名或其他使用这些方法的代码。</p>\n<ol start=\"2\">\n<li><strong>修改内部实现时不会影响到使用该对象的代码体现在</strong>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> String username;<br><span class=\"hljs-keyword\">private</span> String password;<br></code></pre></td></tr></table></figure>\n<p>因为 <code>username</code> 和 <code>password</code> 是私有属性，所以它们对外部代码是不可见和不可访问的。我们可以在不改变任何使用 <code>UserCredentials</code> 对象的代码的情况下，自由改变这些属性的内部表示方法（比如对密码进行加密存储）。因为任何这样的改变都会被 <code>UserCredentials</code> 类的公共接口所封装和抽象化，从而不会泄露出去或者影响到依赖于这些公共接口的代码。</p>\n<ul>\n<li><strong>接口与实现分离</strong>：提供清晰的接口，使得对象之间的依赖关系只基于接口，降低了耦合度</li>\n</ul>\n<ol>\n<li><strong>提供清晰的接口体现在</strong>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">authenticate</span><span class=\"hljs-params\">(String inputPassword)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">resetPassword</span><span class=\"hljs-params\">(String oldPassword, String newPassword)</span>;<br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getUsername</span><span class=\"hljs-params\">()</span>;<br></code></pre></td></tr></table></figure>\n<p>这些公共方法形成了 <code>UserCredentials</code> 类的接口，它为外部代码提供了清晰的通信协议，明确了可以进行的操作。使用这个类的代码只需要知道这些方法的声明和预期行为，不需要了解它们背后的具体实现。</p>\n<ol start=\"2\">\n<li><strong>使得对象之间的依赖关系只基于接口体现在</strong>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">UserCredentials</span> <span class=\"hljs-variable\">credentials</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UserCredentials</span>(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;password&quot;</span>);<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">valid</span> <span class=\"hljs-operator\">=</span> credentials.authenticate(<span class=\"hljs-string\">&quot;password&quot;</span>);<br></code></pre></td></tr></table></figure>\n<p>只要 <code>authenticate</code> 方法的接口保持不变，外部代码就可以正常工作，完全无须关心 <code>UserCredentials</code> 内部是如何处理认证逻辑的。</p>\n<ol start=\"3\">\n<li><strong>降低了耦合度体现在</strong>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setPassword</span><span class=\"hljs-params\">(String password)</span> &#123;<br>    <span class=\"hljs-comment\">// 假设这里改用了一种新的加密方式来设置密码</span><br>    <span class=\"hljs-built_in\">this</span>.password = encryptPassword(password);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>即使改变了 <code>setPassword</code> 方法的内部实现（如加密），由于这个方法是私有的，外部代码不会受到影响。这种隔离提高了系统的模块化，使得各个部分可以独立变化而不互相干扰，从而降低了耦合度。</p>\n<ul>\n<li><strong>隐藏实现细节，简化接口</strong>：用户只需知道对象公开的方法，不必了解其内部的复杂过程</li>\n</ul>\n<h2 id=\"应用场景\">应用场景<a title=\"#应用场景\" href=\"#应用场景\"></a></h2>\n<p>封装的应用场景：</p>\n<ul>\n<li><strong>类的设计</strong>：在类定义时，通常将属性私有化(private)，通过公共的方法（public methods）来访问和修改这些属性</li>\n<li><strong>模块化组件</strong>：在设计模块化的系统时，每个组件都通过封装来定义自己的行为和接口，使得系统更易于组合和扩展</li>\n<li><strong>库和框架的开发</strong>：开发者提供库和框架时，会通过封装隐藏复杂逻辑，只暴露简洁的 API 接口给其他开发者使用</li>\n<li><strong>隔离变化</strong>：将可能变化的部分封装起来，变化发生时，只需修改封装层内部，不影响外部使用</li>\n</ul>\n<blockquote>\n<p>通过封装，能够构建出结构清晰、易于管理和维护的代码。</p>\n</blockquote>\n<p>完整代码可在此查阅：<a href=\"https://github.com/BNTang/Java-All/tree/main/java-infrastructural/src/main/java/top/it6666/encapsulation\" target=\"_blank\">GitHub</a></p>\n<h1 id=\"继承（inheritance）\">继承（Inheritance）<a title=\"#继承（inheritance）\" href=\"#继承（inheritance）\"></a></h1>\n<p>继承是一种能够让新创建的类（子类或派生类）接收另一个类（父类或基类）的属性和方法的机制。</p>\n<p>在 Java 中，继承是通过使用 <code>extends</code> 关键字来实现的。从理论上解释一下，然后再通过代码示例来加深理解。</p>\n<h2 id=\"is-a-关系\">IS-A 关系<a title=\"#is-a-关系\" href=\"#is-a-关系\"></a></h2>\n<p>IS-A 是一种表达类之间关系的方式，主要用来表明一个实体（子类）是另一个实体（父类）的一种特殊类型。例如，Cat（猫）是 Animal（动物）的一种特殊类型。因此，可以说 Cat IS-A Animal。</p>\n<h2 id=\"里氏替换原则（liskov-substitution-principle）\">里氏替换原则（Liskov Substitution Principle）<a title=\"#里氏替换原则（liskov-substitution-principle）\" href=\"#里氏替换原则（liskov-substitution-principle）\"></a></h2>\n<p>这是一个面向对象设计的原则，它表明如果 S 是 T 的一个子类型（在 Java 中意味着 S 类继承自 T 类），那么任何期望 T 类的对象的地方都可以用 S 类的对象来替换，而不会影响程序的行为。</p>\n<h2 id=\"向上转型（upcasting）\">向上转型（Upcasting）<a title=\"#向上转型（upcasting）\" href=\"#向上转型（upcasting）\"></a></h2>\n<p>向上转型是指子类类型的引用自动转换成父类类型。向上转型在多态中是常见的，它允许将子类的对象赋值给父类的引用。例如，可以将 Cat 类型的对象赋值给 Animal 类型的引用。</p>\n<p>以代码形式展示上述概念：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 动物</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> BNTang</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@date</span> 2024/03/10 09:36:41</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@description</span> 创建一个表示动物的基类（父类）</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-comment\">// 动物类有一个叫的方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 创建一个 Cat 类（子类），继承自 Animal 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-comment\">// 重写父类的 makeSound 方法</span><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-comment\">// 这里的调用体现了多态性，即 Cat 的叫声不同于一般 Animal</span><br>        System.out.println(<span class=\"hljs-string\">&quot;猫咪喵喵叫&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InheritanceExample</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// Upcasting: 将 Cat 对象向上转型为 Animal 类型</span><br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">myAnimal</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>        <span class=\"hljs-comment\">// 虽然 myAnimal 在编译时是 Animal 类型，但实际执行的是 Cat 的 makeSound 方法</span><br>        myAnimal.makeSound();<br><br>        <span class=\"hljs-comment\">// 创建一个 Animal 类型的对象，调用 makeSound 方法</span><br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">anotherAnimal</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>();<br>        anotherAnimal.makeSound();<br><br>        <span class=\"hljs-comment\">// 这里可以看到，Cat 对象（myAnimal）能够替换 Animal 对象（anotherAnimal）的位置，</span><br>        <span class=\"hljs-comment\">// 并且程序的行为没有发生错误，体现了里氏替换原则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>定义了两个类：Animal 和 Cat。</p>\n<p>Cat 类继承自 Animal 类，并重写了 makeSound 方法。在 main 方法中，创建了一个 Cat 对象，并将其向上转型为 Animal 类型的引用 myAnimal。调用 myAnimal 的 makeSound 方法时，会执行 Cat 类的重写方法而不是 Animal 类的方法，这就体现了多态性和里氏替换原则。同时，Cat 对象（向上转型后的 myAnimal）可以在任何需要 Animal 对象的地方使用，这也满足了 IS-A 关系的定义</p>\n<p>完整代码可在此查阅：<a href=\"https://github.com/BNTang/Java-All/tree/main/java-infrastructural/src/main/java/top/it6666/inheritance\" target=\"_blank\">GitHub</a></p>\n<h1 id=\"多态（polymorphism）\">多态（Polymorphism）<a title=\"#多态（polymorphism）\" href=\"#多态（polymorphism）\"></a></h1>\n<p>多态可以允许使用一个统一的接口来操作不同的底层数据类型或对象。多态分为 <code>编译时</code> 多态和 <code>运行时</code> 多态两种类型。<br>\n编译时多态（方法的重载），也被称为静态多态，主要是通过 <code>方法重载</code>（Method Overloading）来实现的。方法重载指的是在同一个类中存在多个同名的方法，但这些方法的参数列表不同（参数数量或类型不同）。</p>\n<p>编译器根据方法被调用时传入的参数类型和数量，来决定具体调用哪个方法。这种决策是在编译时做出的，因此称为编译时多态。</p>\n<h2 id=\"方法重载\">方法重载<a title=\"#方法重载\" href=\"#方法重载\"></a></h2>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打印机类</span><br><span class=\"hljs-comment\"> * 用于演示方法重载</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> BNTang</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Printer</span> &#123;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 打印字符串</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> content 要打印的字符串</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(String content)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;打印字符串: &quot;</span> + content);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 重载 print 方法，参数类型为 int，与打印字符串的方法区分开来</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> number 要打印的数字</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> number)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;打印数字: &quot;</span> + number);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OverloadingExample</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">Printer</span> <span class=\"hljs-variable\">printer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Printer</span>();<br><br>        <span class=\"hljs-comment\">// 调用 print 方法打印字符串</span><br>        printer.print(<span class=\"hljs-string\">&quot;Hello, World!&quot;</span>);<br><br>        <span class=\"hljs-comment\">// 调用重载的 print 方法打印数字</span><br>        printer.print(<span class=\"hljs-number\">12345</span>);<br><br>        <span class=\"hljs-comment\">// 编译器根据参数类型来决定调用哪个方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>运行时多态，也被称为动态多态或动态绑定，是通过 <code>方法覆盖</code>（Method Overriding）实现的。</p>\n<p>运行时多态是在继承的基础上工作的，所以只要其中子类覆盖父类的方法。</p>\n<p>运行时多态的决策是在程序执行期间进行的，即虚拟机在运行时刻根据对象的实际类型来确定调用哪个类中的方法。</p>\n<h2 id=\"方法覆盖\">方法覆盖<a title=\"#方法覆盖\" href=\"#方法覆盖\"></a></h2>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 动物</span><br><span class=\"hljs-comment\"> * 创建一个表示动物的基类（父类）</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> BNTang</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">makeSound</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;汪汪汪&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PolymorphismExample</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 向上转型</span><br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">animal</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><br>        <span class=\"hljs-comment\">// 运行时多态，调用的是 Dog 类的 makeSound 方法</span><br>        animal.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>虽然在编译时 <code>animal</code> 的类型是 <code>Animal</code>，但是在运行时 JVM 会调用实际对象类型（也就是 <code>Dog</code>）的 <code>makeSound</code> 方法，因此输出的将是 “汪汪汪”，而不是 “动物发出声音”。这就是运行时多态的体现。</p>\n<p>运行时多态的三个条件</p>\n<ol>\n<li><strong>继承</strong>：子类需要继承父类</li>\n<li><strong>方法覆盖</strong>：子类需要提供一个具体的实现，这个实现覆盖了父类的方法</li>\n<li><strong>向上转型</strong>：你可以将子类类型的引用转换为父类类型的引用（即将子类对象赋值给父类引用），之后通过这个父类引用来调用方法时，执行的将是子类的覆盖实现</li>\n</ol>\n<p>利用多态写出可扩展性和可维护性更佳的代码，能够应对不断变化的需求。使得可以通过相同的接口来调用不同类的实现，提供了软件设计的灵活性。</p>\n<p>完整代码可在此查阅：<a href=\"https://github.com/BNTang/Java-All/tree/main/java-infrastructural/src/main/java/top/it6666/polymorphism\" target=\"_blank\">GitHub</a></p>\n<h1 id=\"抽象（abstraction）\">抽象（Abstraction）<a title=\"#抽象（abstraction）\" href=\"#抽象（abstraction）\"></a></h1>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202312/2105804-20231211215004818-977875224.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"『Java 语法基础』a = a + b 与 a += b 的区别","link":"2024/03/11/面试题/Java/Java 基础/02-『Java 语法基础』a = a + b 与 a += b 的区别"},"next":{"title":"【UniApp】自定义组件","link":"2024/03/04/Web/UniApp/【UniApp】自定义组件"},"plink":"http://example.com/2024/03/06/面试题/Java/Java 基础/01-『语法基础』面向对象有哪些特性/","toc":[{"id":"封装（encapsulation）","title":"封装（Encapsulation）","index":"1","children":[{"id":"优势","title":"优势","index":"1.1"},{"id":"应用场景","title":"应用场景","index":"1.2"}]},{"id":"继承（inheritance）","title":"继承（Inheritance）","index":"2","children":[{"id":"is-a-关系","title":"IS-A 关系","index":"2.1"},{"id":"里氏替换原则（liskov-substitution-principle）","title":"里氏替换原则（Liskov Substitution Principle）","index":"2.2"},{"id":"向上转型（upcasting）","title":"向上转型（Upcasting）","index":"2.3"}]},{"id":"多态（polymorphism）","title":"多态（Polymorphism）","index":"3","children":[{"id":"方法重载","title":"方法重载","index":"3.1"},{"id":"方法覆盖","title":"方法覆盖","index":"3.2"}]},{"id":"抽象（abstraction）","title":"抽象（Abstraction）","index":"4"}],"reading_time":"3720 words in 25 min"}
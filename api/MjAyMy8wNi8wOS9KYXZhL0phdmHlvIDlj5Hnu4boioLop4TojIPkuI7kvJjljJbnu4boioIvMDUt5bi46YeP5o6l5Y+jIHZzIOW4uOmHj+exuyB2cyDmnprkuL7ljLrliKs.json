{"title":"常量接口 vs 常量类 vs 枚举区别","date":"2023-06-09T07:03:46.000Z","date_formatted":{"ll":"Jun 9, 2023","L":"06/09/2023","MM-DD":"06-09"},"link":"2023/06/09/Java/Java开发细节规范与优化细节/05-常量接口 vs 常量类 vs 枚举区别","tags":["Java开发细节规范与优化细节"],"updated":"2023-06-10T16:18:01.929Z","content":"<p>把常量定义在接口里与类里都能通过编译，那2者到底有什么区别呢？</p>\n<p>那个更合理？</p>\n<h1 id=\"常量接口\">常量接口<a title=\"#常量接口\" href=\"#常量接口\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ConstInterfaceA</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">CONST_A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;aa&quot;</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">CONST_C</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;cc&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>存在问题:</p>\n<ol>\n<li>无法限制开发人员, 继承/实现接口</li>\n<li>开发人员能够在子接口里继续添加常量，而这些常量可能得不到祖先层的支持</li>\n<li>常量作为参数时, 是 String, int 等弱类型, 开发人员可以传入没有在常量接口里定义的值, 这个问题无法通过编译器发现</li>\n<li>由于开发人员可以直接写常量值, 所以不能用 <code>==</code> 对比, 只能用 <code>equals</code> 对比, 不能优化性能</li>\n<li>开发人员在没有参考资料时, 不可能知道某个 int 型的参数到底应该赋什么内容</li>\n<li>编译时, 是直接把常量的值编译到类的二进制代码里, 常量的值在升级中变化后, 需要重新编译所有引用常量的类, 因为里面存的是旧值</li>\n</ol>\n<h1 id=\"常量类\">常量类<a title=\"#常量类\" href=\"#常量类\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConstClassA</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">CONST_A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;aa&quot;</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">CONST_C</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;cc&quot;</span>;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">ConstClassA</span><span class=\"hljs-params\">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>常量类可以设置构造函数为 <code>private</code></li>\n<li>从而限制继承, 也就没有继续添加常量的问题了</li>\n<li>但是其他问题与常量接口一样无法解决</li>\n</ul>\n<h1 id=\"枚举常量类\">枚举常量类<a title=\"#枚举常量类\" href=\"#枚举常量类\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EnumClassA</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> String name;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">EnumClassA</span><span class=\"hljs-params\">(String name)</span> &#123;<br>   \t\t <span class=\"hljs-built_in\">this</span>.name = name;<br>\t  &#125;<br>  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">EnumClassA</span> <span class=\"hljs-variable\">CONST_A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumClassA</span>(<span class=\"hljs-string\">&quot;aa&quot;</span>);<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">EnumClassA</span> <span class=\"hljs-variable\">CONST_C</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumClassA</span>(<span class=\"hljs-string\">&quot;cc&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>解决了以上所有问题, 主要体现在:</p>\n<ol>\n<li>私有构造函数, 避免被继承和扩展</li>\n<li>定义方法的参数时, 必须用枚举常量类类型, 如上面的 <code>EnumClassA</code> 类型, 这样就转变成了强类型, 不会出现弱类型引起的问题</li>\n<li>常量值地址唯一, 可以用 <code>==</code> 直接对比, 性能会有提高</li>\n<li>开发人员可以根据该参数类型打开对应的类, 从而找到定义的常量</li>\n<li>编译时, 没有把常量值编译到代码里, 即使常量的值发生变化也不会影响引用常量的类</li>\n</ol>\n<h1 id=\"enum-类型\">enum 类型<a title=\"#enum-类型\" href=\"#enum-类型\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Grade</span> &#123;<br>    A(<span class=\"hljs-number\">4</span>),<br>    B(<span class=\"hljs-number\">3</span>),<br>    C(<span class=\"hljs-number\">2</span>),<br>    D(<span class=\"hljs-number\">1</span>),<br>    F(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> points;<br>    <br>    Grade(<span class=\"hljs-type\">int</span> points) &#123;<br>   \t\t <span class=\"hljs-built_in\">this</span>.points = points;<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getPoints</span><span class=\"hljs-params\">()</span> &#123;<br>    \t<span class=\"hljs-keyword\">return</span> points;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>这是 <code>JDK 1.5</code> 引入的, 其实就是枚举常量类的代码封装简化而已</li>\n<li>查看 enum 反编译后的代码与枚举常量类的结构非常相似</li>\n<li>这可能是因为 java 的设计者一开始觉得 enum 与 OO 思想不符</li>\n<li>所以没有提供支持, 但是随着常量接口的滥用和枚举常量类方案的出现</li>\n<li>才在 JDK 1.5 里增加了 enum</li>\n</ul>\n","prev":{"title":"Java 命名规范","link":"2023/06/10/Java/Java开发细节规范与优化细节/06-Java 命名规范"},"next":{"title":"Java开发中PO、VO、DAO、BO、DTO、POJO 含义","link":"2023/06/08/Java/Java开发细节规范与优化细节/04-Java开发中PO、VO、DAO、BO、DTO、POJO 含义"},"plink":"http://example.com/2023/06/09/Java/Java开发细节规范与优化细节/05-常量接口 vs 常量类 vs 枚举区别/","toc":[{"id":"常量接口","title":"常量接口","index":"1"},{"id":"常量类","title":"常量类","index":"2"},{"id":"枚举常量类","title":"枚举常量类","index":"3"},{"id":"enum-类型","title":"enum 类型","index":"4"}],"reading_time":"727 words in 5 min"}
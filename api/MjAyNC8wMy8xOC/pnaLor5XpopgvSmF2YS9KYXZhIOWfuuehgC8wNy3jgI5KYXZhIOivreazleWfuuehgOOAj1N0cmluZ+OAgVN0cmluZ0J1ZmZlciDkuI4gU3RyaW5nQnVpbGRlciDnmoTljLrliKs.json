{"title":"『Java 语法基础』String、StringBuffer 与 StringBuilder 的区别","date":"2024-03-17T16:18:55.000Z","date_formatted":{"ll":"Mar 18, 2024","L":"03/18/2024","MM-DD":"03-18"},"link":"2024/03/18/面试题/Java/Java 基础/07-『Java 语法基础』String、StringBuffer 与 StringBuilder 的区别","tags":["Java"],"updated":"2024-03-17T17:02:23.843Z","content":"<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202403/2105804-20240318001758240-2013969616.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p>第一点: 可变和适用范围。String 对象是不可变的，而 StringBuffer 和 StringBuilder 是可变字符序列。每次对 String 的操作相当于生成一个新的 String 对象，而对 StringBuffer 和 StringBuilder 的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用 String，因为频繁的生成对象将会对系统性能产生影响。</p>\n</blockquote>\n<p>String、StringBuffer 和 StringBuilder 这三者在处理字符串时各有不同。String 类型是  Java 中的基本数据类型之一，它代表不可变的字符序列。这意味着一旦一个 String 对象被创建，那么它所包含的字符序列就不能被更改了。</p>\n<p>举个例子，如果你想在一个字符串后面加上另外一些文字，如果你是用 String 来处理，每次添加操作实际上都会在内存中创建一个新的 String 对象来保存新的字符序列，旧的 String 对象则可能被垃圾回收机制回收（如果没有其它引用指向它）。这个过程是隐形的，你看不到，但是它确实在发生，尤其是当有很多字符串操作的时候，这会造成内存的浪费和额外的性能开销。</p>\n<p>相对于 String，StringBuffer 和 StringBuilder 是可变的字符序列。这意味着你可以直接在原有对象的基础上添加新内容或者更改内容，而不需要每次都创建一个新的对象。这使得它们在处理需要频繁修改内容的字符串时更加高效。</p>\n<p>那么，它们两个有什么区别呢？</p>\n<p>StringBuffer 是线程安全的，也就是说当多个线程同时试图修改同一个 StringBuffer 对象时，它可以保证数据的正确性和一致性。而 StringBuilder 则没有这种线程安全的保证，但是在单线程环境下，它的性能要优于 StringBuffer，因为它避免了线程安全带来的性能开销。</p>\n<p>用一个简单的比喻来理解这三者的区别: 如果把字符串比作一束花束，那么一个 String 就像是用一次性花瓶装饰的花束。每当你想换一束花，你就需要一个新的花瓶。而 StringBuffer 和 StringBuilder 就像是可以重复使用的花瓶。你可以随时往里面添加新的花朵（字符），或者拿掉一些花朵，而不需要每次都换一个新的花瓶。如果你家里只有你一个人（单线程），那么用 StringBuilder 就足够了，如果你家里同时有很多人可能同时去改变这束花（多线程），那么你可能就需要一个有更好锁机制的花瓶，也就是 StringBuffer。</p>\n<p>在实际开发中，如果一个字符串不会被多个线程同时修改，那么推荐使用 StringBuilder，因为它通常会给你带来更好的性能；如果字符串安全性是个问题，那么你可能需要使用 StringBuffer。而当确定字符串的内容在创建后不会再发生变化时，你可以使用 String。</p>\n<blockquote>\n<p>第二点: 线程安全。String 由于有 final 修饰，是 immutable 的，安全性是简单而纯粹的。StringBuilder 和 StringBuffer 的区别在于 StringBuilder 不保证同步，也就是说如果需要线程安全需要使用 StringBuffer，不需要同步的 StringBuilder 效率更高。</p>\n</blockquote>\n<p>想象一下你在一家餐厅里做厨师，而字符串就像是你正在准备的一道菜。</p>\n<p><strong>String</strong> 像是一家只接受外卖订单的餐厅，顾客点了什么菜，你就准备什么，整个过程非常简单和直接。一旦菜做好并打包好，就不能再改了——如果顾客想加点什么调料或者改变一下，你需要重新准备一份新的菜。这种方式非常安全，因为每个订单都是独立处理，不会相互影响。</p>\n<p><strong>StringBuffer</strong> 就像一家忙碌的餐厅，有很多服务员和厨师同时工作。在这种环境下，你需要确保不会有两个人同时去盛一样的菜导致混乱。为此，餐厅里有一个规则，就是在一个人准备某道菜的时候，其他人必须等他完成才能开始他们的工作。这就相当于线程安全，StringBuffer 就是这样工作的，它有一套内建的机制来保证即使多个线程尝试修改同一个字符串，每个修改还是会被逐个顺序地处理，不会造成混乱。</p>\n<p><strong>StringBuilder</strong> 在这个比喻中，就像是只有一个厨师在厨房里工作。由于同一时间只有他一个人在那里，所以不需要担心会有其他人跟他抢着去做同一件事。这就意味着他可以更加高效地工作，不需要等待也不需要遵守轮流的规则。在程序中，如果你知道只有一个线程会修改字符串，那么使用 StringBuilder 就足够了，因为它不带线程安全的额外开销，因此可以更快地完成任务。</p>\n<p>简而言之，在需要考虑数据在多个线程之间共享并且可能同时被修改的情况下，为了保证数据的一致性和完整性，你就需要像 StringBuffer 这样的线程安全的选项。如果没有这种需要，那么 StringBuilder 就是一个更快速的选择。而 String 始终是不可变的，适合那些一旦创建就不需要修改的场景。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202312/2105804-20231211215004818-977875224.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"『Echarts』绘制饼状图","link":"2024/03/20/Web/ECharts/06-『Echarts』绘制饼状图"},"next":{"title":"『Java 语法基础』final、finalize 和 finally 的不同之处","link":"2024/03/17/面试题/Java/Java 基础/06-『Java 语法基础』final、finalize 和 finally 的不同之处"},"plink":"http://example.com/2024/03/18/面试题/Java/Java 基础/07-『Java 语法基础』String、StringBuffer 与 StringBuilder 的区别/","reading_time":"1453 words in 10 min"}
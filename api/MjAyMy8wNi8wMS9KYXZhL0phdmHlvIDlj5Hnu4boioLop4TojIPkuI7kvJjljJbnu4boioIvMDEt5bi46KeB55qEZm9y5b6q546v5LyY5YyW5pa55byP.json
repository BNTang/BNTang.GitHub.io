{"title":"常见的for循环优化方式","date":"2023-06-01T15:22:37.000Z","date_formatted":{"ll":"Jun 1, 2023","L":"06/01/2023","MM-DD":"06-01"},"link":"2023/06/01/Java/Java开发细节规范与优化细节/01-常见的for循环优化方式","tags":["Java开发细节规范与优化细节"],"updated":"2023-06-04T13:43:17.022Z","content":"<p>?&gt; 前言</p>\n<p>经常使用一些循环，进行耗时计算的操作，特别是 for 循环，它是一种重复计算的操作，如果处理不好，耗时就比较大，如果处理书写得当，将大大提高效率，下面总结几条 for 循环的常见优化方式。</p>\n<p>首先初始化一个集合 list，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n<h1 id=\"方式一：最常规的不加思考的写法\">方式一：最常规的不加思考的写法<a title=\"#方式一：最常规的不加思考的写法\" href=\"#方式一：最常规的不加思考的写法\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>优点：较常见，易于理解</li>\n<li>缺点：每次都要计算 <code>list.size()</code></li>\n</ul>\n<h1 id=\"方式二：数组长度提取出来\">方式二：数组长度提取出来<a title=\"#方式二：数组长度提取出来\" href=\"#方式二：数组长度提取出来\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> list.size();<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; size; i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>优点：不必每次都计算 <code>list.size()</code></li>\n<li>缺点：\n<ul>\n<li>size 的作用域不够小，违反了最小作用域原则</li>\n<li>不能在 for 循环中操作 list 的大小，比如除去或新加一个元素</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法三：数组长度提取出来\">方法三：数组长度提取出来<a title=\"#方法三：数组长度提取出来\" href=\"#方法三：数组长度提取出来\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>, size = list.size(); i &lt; size; i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>优点：不必每次都计算，变量的作用域遵循最小范围原则</li>\n<li>缺点：\n<ul>\n<li>size 的作用域不够小，违反了最小作用域原则</li>\n<li>不能在 for 循环中操作 list 的大小，比如除去或新加一个元素</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法四：采用倒序的写法\">方法四：采用倒序的写法<a title=\"#方法四：采用倒序的写法\" href=\"#方法四：采用倒序的写法\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> list.size() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>优点：不必每次都计算，变量的作用域遵循最小范围原则</li>\n<li>缺点：\n<ul>\n<li>1、结果的顺序会反</li>\n<li>2、看起来不习惯，不易读懂</li>\n</ul>\n</li>\n<li>适用场合：与显示结果顺序无关的地方：比如保存之前数据的校验</li>\n</ul>\n<h1 id=\"方法五：iterator-遍历\">方法五：Iterator 遍历<a title=\"#方法五：iterator-遍历\" href=\"#方法五：iterator-遍历\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>    System.out.println(it.next());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>优点：简洁</li>\n</ul>\n<h1 id=\"方法六：jdk-1.5-后的写法\">方法六：jdk 1.5 后的写法<a title=\"#方法六：jdk-1.5-后的写法\" href=\"#方法六：jdk-1.5-后的写法\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (String o : list) &#123;<br>    System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>优点：简洁, 结合泛型使用更简洁</li>\n<li>缺点：jdk 1.4 向下不兼容(也就是 &lt; 1.5 版本就不能这么写)</li>\n</ul>\n<h1 id=\"方法七：循环嵌套外小内大原则\">方法七：循环嵌套外小内大原则<a title=\"#方法七：循环嵌套外小内大原则\" href=\"#方法七：循环嵌套外小内大原则\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"原因\">原因<a title=\"#原因\" href=\"#原因\"></a></h2>\n<p>?&gt; 分支优化规则</p>\n<p>引入流水线工作机制以后，为了配合流水线工作，处理器增加了一个分支目标缓冲器(Branch Target Buffer)。在流水线工作模式下，如果遇到分支结构，就可以利用分支目标缓冲器预测并读取指令的目标地址。分支目标缓冲器在程序运行时将动态记录和调整转移指令的目标地址，可以记录多个地址，对其进行表格化管理。当发生转移时，如果分支目标缓冲器中有记录，下一条指令在取指令阶段就会将其作为目标地址。如果记录地址等于实际目标地址，则并行成功；如果记录地址不等于实际目标地址，则流水线被冲洗。同一个分支，多次预测失败，则更新记录的目标地址。因此，分支预测属于 “经验主义” 或 “机会主义&quot;，会存在一定的误测。</p>\n<p>基于上述原因，大家以后在编写多重循环时应该把大循环放到内层，这样可以增加分支预测的准确度，如下面的示例所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[][] a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10000</span>];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>    <span class=\"hljs-comment\">// 下面每次循环会预测成功9999次</span><br>    <span class=\"hljs-comment\">// 第1次没有预测，最后退出循环时预测失败1次这样的</span><br>    <span class=\"hljs-comment\">// 过程重复10次</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>        a[i][j]++;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>    <span class=\"hljs-comment\">// 下面每次循环会预测成功9次</span><br>    <span class=\"hljs-comment\">// 第1次没有预测，最后退出循环时预测失败1次</span><br>    <span class=\"hljs-comment\">// 这样的过程重复10000次</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>        a[i][j]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"方法八：循环嵌套提取不需要循环的逻辑\">方法八：循环嵌套提取不需要循环的逻辑<a title=\"#方法八：循环嵌套提取不需要循环的逻辑\" href=\"#方法八：循环嵌套提取不需要循环的逻辑\"></a></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 前：</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>, b = <span class=\"hljs-number\">11</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>    i = i * a * b;<br>&#125;<br><br><span class=\"hljs-comment\">// 后：</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> a * b;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>    i = i * c;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"方法九：异常处理写在循环外面\">方法九：异常处理写在循环外面<a title=\"#方法九：异常处理写在循环外面\" href=\"#方法九：异常处理写在循环外面\"></a></h1>\n<p>反例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br><br>    &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>正例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>    &#125;<br>&#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n","prev":{"title":"Java常用重构技巧","link":"2023/06/05/Java/Java开发细节规范与优化细节/02-Java常用重构技巧"},"next":{"title":"Keepalived 安装与配置","link":"2023/05/28/DevOps与云原生/Keepalive+Haproxy 高可用搭建/05-keepalive安装与配置"},"plink":"http://example.com/2023/06/01/Java/Java开发细节规范与优化细节/01-常见的for循环优化方式/","toc":[{"id":"方式一：最常规的不加思考的写法","title":"方式一：最常规的不加思考的写法","index":"1"},{"id":"方式二：数组长度提取出来","title":"方式二：数组长度提取出来","index":"2"},{"id":"方法三：数组长度提取出来","title":"方法三：数组长度提取出来","index":"3"},{"id":"方法四：采用倒序的写法","title":"方法四：采用倒序的写法","index":"4"},{"id":"方法五：iterator-遍历","title":"方法五：Iterator 遍历","index":"5"},{"id":"方法六：jdk-1.5-后的写法","title":"方法六：jdk 1.5 后的写法","index":"6"},{"id":"方法七：循环嵌套外小内大原则","title":"方法七：循环嵌套外小内大原则","index":"7","children":[{"id":"原因","title":"原因","index":"7.1"}]},{"id":"方法八：循环嵌套提取不需要循环的逻辑","title":"方法八：循环嵌套提取不需要循环的逻辑","index":"8"},{"id":"方法九：异常处理写在循环外面","title":"方法九：异常处理写在循环外面","index":"9"}],"reading_time":"1111 words in 7 min"}
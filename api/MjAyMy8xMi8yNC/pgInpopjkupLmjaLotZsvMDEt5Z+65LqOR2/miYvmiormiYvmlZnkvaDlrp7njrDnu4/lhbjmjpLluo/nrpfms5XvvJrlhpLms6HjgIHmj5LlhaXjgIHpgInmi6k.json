{"title":"基于Go手把手教你实现经典排序算法：冒泡、插入、选择","date":"2023-12-24T06:21:17.000Z","date_formatted":{"ll":"Dec 24, 2023","L":"12/24/2023","MM-DD":"12-24"},"link":"2023/12/24/选题互换赛/01-基于Go手把手教你实现经典排序算法：冒泡、插入、选择","tags":["go","选题互换赛"],"updated":"2023-12-24T06:26:40.039Z","content":"<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/2ef7c44067816cfba805e30016fc3405.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>排序算法是计算机科学中一种基本的算法，它可以对输入数据进行排序，使得数据按照一定的顺序排列。冒泡排序、插入排序和选择排序是三种简单但实用的排序算法。它们都是比较排序算法，即通过比较两个元素的大小来确定它们的顺序。</p>\n<p>这三种排序算法都是简单易懂的，但它们在实际应用中可能会比较慢，因为它们的复杂度都是O(n^2)。在实际应用中，我们通常会使用更高效的排序算法，如归并排序、快速排序等。但是，对于小规模的数据或者初学者来说，这三种排序算法是很好的入门选择。那么我们来一探究竟吧~</p>\n<h1 id=\"冒泡排序\">冒泡排序<a title=\"#冒泡排序\" href=\"#冒泡排序\"></a></h1>\n<p>冒泡排序**（Bubble Sort）**是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/fd0ef2b8fe40765448f225174b1aaefe.png?qc_blockWidth=620&amp;qc_blockHeight=552\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/b9bdb820be78a17303b575d22efae3d8.png?qc_blockWidth=620&amp;qc_blockHeight=663\" alt loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">bubbleSort</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    n := <span class=\"hljs-built_in\">len</span>(arr)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>        <span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; n-i<span class=\"hljs-number\">-1</span>; j++ &#123;<br>            <span class=\"hljs-keyword\">if</span> arr[j] &gt; arr[j+<span class=\"hljs-number\">1</span>] &#123;<br>                arr[j], arr[j+<span class=\"hljs-number\">1</span>] = arr[j+<span class=\"hljs-number\">1</span>], arr[j]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    arr := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">90</span>&#125;<br>    fmt.Println(<span class=\"hljs-string\">&quot;排序前:&quot;</span>, arr)<br>    bubbleSort(arr)<br>    fmt.Println(<span class=\"hljs-string\">&quot;排序后:&quot;</span>, arr)<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/ac3f5c81d64a8e7e2a650ebd4baaff86.png?qc_blockWidth=620&amp;qc_blockHeight=173\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>解释一下：</p>\n<ol>\n<li>首先，我们获取输入数组的长度n，这将用于遍历数组。</li>\n<li>然后，我们使用一个外部循环for i := 0; i &lt; n; i++来遍历数组中的每个元素，从第一个元素开始，直到最后一个元素。</li>\n<li>在外部循环中，我们使用一个内部循环for j := 0; j &lt; n-i-1; j++来遍历当前未排序部分的每个相邻的两个元素，从第一个元素开始，直到倒数第二个元素。</li>\n<li>在内部循环中，我们使用if语句来比较当前元素arrj和下一个元素arrj+1的大小。如果当前元素大于下一个元素，我们将它们交换位置，即将arrj赋值为arrj+1，将arrj+1赋值为arrj。</li>\n<li>内部循环结束后，最大的元素将被移动到数组的末尾。</li>\n<li>外部循环结束后，整个数组就已经排好序了。</li>\n</ol>\n<h1 id=\"插入排序\">插入排序<a title=\"#插入排序\" href=\"#插入排序\"></a></h1>\n<p>插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/2a22db01540359087cae6fa01350ca6e.png?qc_blockWidth=620&amp;qc_blockHeight=366\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/745e863f8cac2a1e983ae2b258328d84.png?qc_blockWidth=620&amp;qc_blockHeight=663\" alt loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">insertionSort</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    n := <span class=\"hljs-built_in\">len</span>(arr)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; n; i++ &#123;<br>        key := arr[i]<br>        j := i - <span class=\"hljs-number\">1</span><br>        <span class=\"hljs-keyword\">for</span> j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; key &#123;<br>            arr[j+<span class=\"hljs-number\">1</span>] = arr[j]<br>            j = j - <span class=\"hljs-number\">1</span><br>        &#125;<br>        arr[j+<span class=\"hljs-number\">1</span>] = key<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    arr := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">90</span>&#125;<br>    fmt.Println(<span class=\"hljs-string\">&quot;插入排序前:&quot;</span>, arr)<br>    insertionSort(arr)<br>    fmt.Println(<span class=\"hljs-string\">&quot;插入排序后:&quot;</span>, arr)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/c1d43bf0279c8c0e7f333f5c53ab70ae.png?qc_blockWidth=620&amp;qc_blockHeight=178\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>解释一下：</p>\n<ol>\n<li>首先，我们获取输入数组的长度n，这将用于遍历数组。</li>\n<li>然后，我们使用一个外部循环for i := 1; i &lt; n; i++来遍历数组中的每个元素，从第二个元素开始，直到最后一个元素。</li>\n<li>在外部循环中，我们将当前元素arri存储在变量key中，这将用于与前面的元素进行比较。</li>\n<li>接下来，我们使用一个内部循环for j := i - 1; j &gt;= 0 &amp;&amp; arrj &gt; key; j–来遍历当前元素之前的已排序部分，从当前元素的前一个元素开始，直到第一个元素。</li>\n<li>在内部循环中，我们使用if语句来比较当前元素key和前面的元素arrj的大小。如果前面的元素大于当前元素，我们将前面的元素向右移动一位，即将arrj+1赋值为arrj。</li>\n<li>内部循环结束后，我们已经将当前元素key插入到正确的位置，即arrj+1。</li>\n<li>外部循环结束后，整个数组就已经排好序了。</li>\n</ol>\n<h1 id=\"选择排序\">选择排序<a title=\"#选择排序\" href=\"#选择排序\"></a></h1>\n<p>选择排序**（Selection sort）**是一种简单直观的排序算法，它的工作原理是每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/5e8b0fb79970b88dd08f921734bc30b6.png?qc_blockWidth=620&amp;qc_blockHeight=245\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/5a6779ad86b68cf6fa31d308743738eb.png?qc_blockWidth=620&amp;qc_blockHeight=531\" alt loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">selectionSort</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    n := <span class=\"hljs-built_in\">len</span>(arr)<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n<span class=\"hljs-number\">-1</span>; i++ &#123;<br>        minIndex := i<br>        <span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; n; j++ &#123;<br>            <span class=\"hljs-keyword\">if</span> arr[j] &lt; arr[minIndex] &#123;<br>                minIndex = j<br>            &#125;<br>        &#125;<br>        arr[i], arr[minIndex] = arr[minIndex], arr[i]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    arr := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">90</span>&#125;<br>    fmt.Println(<span class=\"hljs-string\">&quot;选择排序前:&quot;</span>, arr)<br>    selectionSort(arr)<br>    fmt.Println(<span class=\"hljs-string\">&quot;选择排序后:&quot;</span>, arr)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/3f5774f806a4beb5392e91c5543ef3c2.png?qc_blockWidth=620&amp;qc_blockHeight=171\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>解释一下：</p>\n<ol>\n<li>首先，我们获取输入数组的长度n，这将用于遍历数组。</li>\n<li>然后，我们使用一个外部循环for i := 0; i &lt; n-1; i++来遍历数组中的每个元素，从第一个元素开始，直到倒数第二个元素。</li>\n<li>在外部循环中，我们初始化一个变量minIndex，它将用于存储当前未排序部分的最小元素的索引。我们将其初始化为当前外部循环的索引i。</li>\n<li>接下来，我们使用一个内部循环for j := i + 1; j &lt; n; j++来遍历当前未排序部分的每个元素，从下一个元素开始，直到最后一个元素。</li>\n<li>在内部循环中，我们使用if语句来比较当前元素arrj和当前最小元素arrminIndex的大小。如果当前元素小于当前最小元素，我们将minIndex更新为当前元素的索引j。</li>\n<li>内部循环结束后，我们已经找到了当前未排序部分的最小元素，并将其索引存储在minIndex中。</li>\n<li>接下来，我们使用arri, arrminIndex = arrminIndex, arri来交换当前元素arri和最小元素arrminIndex的位置。这样，当前元素就被放在了正确的位置上。</li>\n<li>外部循环结束后，整个数组就已经排好序了。</li>\n</ol>\n<h1 id=\"end\">End<a title=\"#end\" href=\"#end\"></a></h1>\n<ul>\n<li>如果你有任何问题或建议，欢迎在下方留言，我会尽快回复</li>\n<li>如果你觉得本文对你有帮助，欢迎点赞、收藏，你的支持是我写作的最大动力</li>\n</ul>\n<p><img src=\"https://developer.qcloudimg.com/http-save/7271764/6a28aa8de195cc5f0acc885541ce3f5e.png?qc_blockWidth=620&amp;qc_blockHeight=264\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"2023岁月留痕,成就新高","link":"2023/12/24/年度总结/01-2023岁月留痕,成就新高"},"next":{"title":"uni-app-打包成App","link":"2023/12/23/Uniapp/26-uni-app-打包成App"},"plink":"http://example.com/2023/12/24/选题互换赛/01-基于Go手把手教你实现经典排序算法：冒泡、插入、选择/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"冒泡排序","title":"冒泡排序","index":"2"},{"id":"插入排序","title":"插入排序","index":"3"},{"id":"选择排序","title":"选择排序","index":"4"},{"id":"end","title":"End","index":"5"}],"reading_time":"1805 words in 12 min"}
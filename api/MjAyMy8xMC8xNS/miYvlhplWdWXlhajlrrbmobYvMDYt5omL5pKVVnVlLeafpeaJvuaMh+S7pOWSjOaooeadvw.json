{"title":"手撕Vue-查找指令和模板","date":"2023-10-14T16:27:46.000Z","date_formatted":{"ll":"Oct 15, 2023","L":"10/15/2023","MM-DD":"10-15"},"link":"2023/10/15/手写Vue全家桶/06-手撕Vue-查找指令和模板","tags":["手写Vue全家桶"],"updated":"2023-10-15T03:09:56.773Z","content":"<p>接着上一篇文章，我们已经实现了提取元素到内存的过程，接下来我们要实现的是查找指令和模板。</p>\n<p>大致的思路是这样的：</p>\n<ol>\n<li>遍历所有的节点</li>\n<li>需要判断当前遍历到的节点是一个元素还是一个文本</li>\n<li>如果是一个元素, 我们需要判断有没有v-model属性</li>\n<li>如果是一个文本, 我们需要判断有没有 <code>&#123;&#123;&#125;&#125;</code> 的内容</li>\n</ol>\n<p>那么随着思路的展开，接下来我们就来实现这个功能。</p>\n<p>首先我们编写一个 buildTemplate 方法，主要功能是利用指定的数据编译内存中的元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">buildTemplate</span>(<span class=\"hljs-params\">fragment</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> nodeList = [...fragment.<span class=\"hljs-property\">childNodes</span>];<br><br>    <span class=\"hljs-comment\">// 1.遍历所有的节点</span><br>    nodeList.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>buildTemplate 方法定义在 Compiler 类中，我们需要在 compile 方法中调用它：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202310/2105804-20231015103932036-711216789.png\" alt=\"image-20231015103931327\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 2.利用指定的数据编译内存中的元素</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">buildTemplate</span>(fragment);<br></code></pre></td></tr></table></figure>\n<p>然后我们在 buildTemplate 方法中完善我们的代码，这里我就先直接上完整的实现代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">buildTemplate</span>(<span class=\"hljs-params\">fragment</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> nodeList = [...fragment.<span class=\"hljs-property\">childNodes</span>];<br><br>    <span class=\"hljs-comment\">// 1.遍历所有的节点</span><br>    nodeList.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>        <span class=\"hljs-comment\">// 2.需要判断当前遍历到的节点是一个元素还是一个文本</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>.<span class=\"hljs-title function_\">isElement</span>(node)) &#123;<br>            <span class=\"hljs-comment\">// 是一个元素</span><br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">buildElement</span>(node);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 不是一个元素</span><br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">buildText</span>(node);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class=\"hljs-title function_\">buildElement</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-comment\">// 可以通过 node.attributes 获取到当前元素上所有的属性</span><br>    <span class=\"hljs-keyword\">let</span> attrs = [...node.<span class=\"hljs-property\">attributes</span>];<br><br>    <span class=\"hljs-comment\">// 1.遍历所有的属性</span><br>    attrs.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">attr</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> &#123;name, value&#125; = attr;<br>        <span class=\"hljs-keyword\">if</span> (name.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;v-&#x27;</span>)) &#123;<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;是Vue的指令, 需要我们处理&#x27;</span>, name);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class=\"hljs-title function_\">buildText</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-comment\">// 可以通过 node.textContent 获取到当前文本节点的内容</span><br>    <span class=\"hljs-keyword\">let</span> content = node.<span class=\"hljs-property\">textContent</span>;<br><br>    <span class=\"hljs-comment\">// 编写一个正则表达式, 用来匹配 &#123;&#123;&#125;&#125;</span><br>    <span class=\"hljs-comment\">// 如下正则表达式的含义是: 匹配 &#123;&#123;&#125;&#125; 中间的内容</span><br>    <span class=\"hljs-comment\">// /: 正则表达式通常以斜杠 / 开始和结束，表示正则表达式的开始和结束。</span><br>    <span class=\"hljs-comment\">// \\&#123; 和 \\&#125;: 这些是转义字符，用于匹配实际的花括号 &#123; 和 &#125;。花括号在正则表达式中具有特殊意义，因此需要使用反斜杠进行转义。</span><br>    <span class=\"hljs-comment\">// \\&#123;\\&#123; 和 \\&#125;\\&#125;: 这是正则表达式的起始和结束部分，用于匹配双花括号 &#123;&#123; 和 &#125;&#125;。</span><br>    <span class=\"hljs-comment\">// .+?: 这部分用于匹配双花括号内的任意字符，. 表示匹配任意字符，+ 表示匹配一个或多个前面的字符，? 表示非贪婪匹配，即尽可能匹配最短的内容。这样确保匹配到最近的结束双花括号 &#125;&#125;。</span><br>    <span class=\"hljs-comment\">// /g: g 是正则表达式的标志，表示全局匹配，即匹配字符串中的所有符合条件的部分。</span><br>    <span class=\"hljs-comment\">// /i: i 也是正则表达式的标志，表示不区分大小写匹配，这意味着 &#123;&#123;...&#125;&#125; 和 &#123;&#123;...&#125;&#125; 都会被匹配到。</span><br>    <span class=\"hljs-comment\">// 因此，这个正则表达式可以用于在字符串中找到并提取所有的 &#123;&#123;...&#125;&#125; 结构，不区分大小写，不贪婪匹配，且匹配所有出现的情况。</span><br>    <span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\&#123;\\&#123;.+?\\&#125;\\&#125;/gi</span>;<br>    <span class=\"hljs-keyword\">if</span> (reg.<span class=\"hljs-title function_\">test</span>(content)) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;是一个文本节点, 需要我们处理&#x27;</span>, content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>好了，我们来看一下效果，我们在浏览器中打开，然后打开控制台，可以看到如下的效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202310/2105804-20231015104503506-161268737.png\" alt=\"image-20231015104503123\" loading=\"lazy\" class=\"φbp\"></p>\n<p>发现，只有 v-model 指令被处理, <code>&#123;&#123;&#125;&#125;</code> 没有被处理，如下图我框出了 <code>&lt;p&gt;</code>：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202310/2105804-20231015104624692-877943285.png\" alt=\"image-20231015104624387\" loading=\"lazy\" class=\"φbp\"></p>\n<p>也就是说我们循环节点的时候，只循环了一层，没有循环到 <code>&lt;p&gt;</code> 标签中的文本节点，所以我们需要修改一下 buildTemplate 方法, 让它支持递归，处理子元素(处理后代)：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202310/2105804-20231015104809591-790170689.png\" alt=\"image-20231015104809104\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 处理子元素(处理后代)</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">buildTemplate</span>(node);<br></code></pre></td></tr></table></figure>\n<p>改造后，我们再来看一下效果，可以看到 <code>&#123;&#123;&#125;&#125;</code> 也被处理了：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202310/2105804-20231015104833958-805317331.png\" alt=\"image-20231015104833637\" loading=\"lazy\" class=\"φbp\"></p>\n<p>好了，到这里我们就实现了查找指令和模板的功能，下一篇我们来继续完善一下我们的不完整的代码，一步一步来慢慢撕。</p>\n","prev":{"title":"手撕Vue-编译指令数据","link":"2023/10/15/手写Vue全家桶/07-手撕Vue-编译指令数据"},"next":{"title":"手撕Vue-提取元素到内存","link":"2023/10/14/手写Vue全家桶/05-手撕Vue-提取元素到内存"},"plink":"http://example.com/2023/10/15/手写Vue全家桶/06-手撕Vue-查找指令和模板/","reading_time":"1081 words in 7 min"}
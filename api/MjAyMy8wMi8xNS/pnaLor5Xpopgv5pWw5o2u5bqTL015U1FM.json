{"title":"MySQL","date":"2023-02-15T04:32:28.000Z","date_formatted":{"ll":"Feb 15, 2023","L":"02/15/2023","MM-DD":"02-15"},"link":"2023/02/15/面试题/数据库/MySQL","tags":["数据库"],"updated":"2023-02-17T08:18:52.435Z","content":"<h1 id=\"能说下myisam-和-innodb的区别吗？\">能说下myisam 和 innodb的区别吗？<a title=\"#能说下myisam-和-innodb的区别吗？\" href=\"#能说下myisam-和-innodb的区别吗？\"></a></h1>\n<ul>\n<li>myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。</li>\n<li>innodb是基于B+Tree索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。</li>\n</ul>\n<h1 id=\"说下mysql的索引有哪些吧？\">说下MySQL的索引有哪些吧？<a title=\"#说下mysql的索引有哪些吧？\" href=\"#说下mysql的索引有哪些吧？\"></a></h1>\n<p>索引在什么层面？</p>\n<p>首先，索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<p>有哪些？</p>\n<ul>\n<li>B+Tree 索引\n<ul>\n<li>是大多数 MySQL 存储引擎的默认索引类型。</li>\n</ul>\n</li>\n<li>哈希索引\n<ul>\n<li>哈希索引能以 O(1) 时间进行查找，但是失去了有序性；</li>\n<li>InnoDB 存储引擎有一个特殊的功能叫 <code>“自适应哈希索引”</code>，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li>\n</ul>\n</li>\n<li>全文索引\n<ul>\n<li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 <code>MATCH AGAINST</code>，而不是普通的 <code>WHERE</code>。</li>\n<li>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</li>\n<li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li>\n</ul>\n</li>\n<li>空间数据索引\n<ul>\n<li>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"什么是b+树？为什么b+树成为主要的sql数据库的索引实现？\">什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？<a title=\"#什么是b+树？为什么b+树成为主要的sql数据库的索引实现？\" href=\"#什么是b+树？为什么b+树成为主要的sql数据库的索引实现？\"></a></h1>\n<ul>\n<li>什么是B+Tree?</li>\n</ul>\n<p>B+Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230215141813672-1185586129.png\" alt=\"image-20230215141813062\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li>为什么是B+Tree?\n<ul>\n<li>为了减少磁盘读取次数，决定了树的高度不能高，所以必须是先B-Tree；</li>\n<li>以页为单位读取使得一次 I/O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个Page页；</li>\n<li>为了支持范围查询以及关联关系，页中数据需要有序，且页的尾部节点指向下个页的头部；</li>\n</ul>\n</li>\n<li>B+树索引可分为聚簇索引和非聚簇索引?\n<ol>\n<li>主索引就是聚簇索引（也称聚集索引，clustered index）</li>\n<li>辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216122226658-4543976.png\" alt=\"image-20230216122222888\" loading=\"lazy\" class=\"φbp\"></p>\n<p>如上图，<strong>主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值</strong>。</p>\n<p>假如要查询name = C 的数据，其搜索过程如下：a) 先在辅助索引中通过C查询最后找到主键id = 9; b) 在主键索引中搜索id为9的数据，最终在主键索引的叶子节点中获取到真正的数据。所以通过辅助索引进行检索，需要检索两次索引。</p>\n<p>之所以这样设计，一个原因就是：如果和MyISAM一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。</p>\n<h1 id=\"那你知道什么是覆盖索引和回表吗？\">那你知道什么是覆盖索引和回表吗？<a title=\"#那你知道什么是覆盖索引和回表吗？\" href=\"#那你知道什么是覆盖索引和回表吗？\"></a></h1>\n<p>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。</p>\n<p>而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。</p>\n<p>比如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">explain <span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">user</span> <span class=\"hljs-keyword\">where</span> age<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">1</span>; <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span> 查询的name无法从索引数据获取<br>explain <span class=\"hljs-keyword\">select</span> id,age <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">user</span> <span class=\"hljs-keyword\">where</span> age<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">1</span>; <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>可以直接从索引获取<br></code></pre></td></tr></table></figure>\n<h1 id=\"什么是mvcc？-说说mysql实现mvcc的原理？\">什么是MVCC？ 说说MySQL实现MVCC的原理？<a title=\"#什么是mvcc？-说说mysql实现mvcc的原理？\" href=\"#什么是mvcc？-说说mysql实现mvcc的原理？\"></a></h1>\n<ul>\n<li>什么是MVCC？</li>\n</ul>\n<p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>\n<p>在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。</p>\n<p>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。</p>\n<ul>\n<li>MySQL的InnoDB引擎实现MVCC的3个基础点</li>\n</ul>\n<ol>\n<li>隐式字段</li>\n</ol>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216123001294-516133616.png\" alt=\"image-20230216122959934\" loading=\"lazy\" class=\"φbp\"></p>\n<p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID是当前操作该记录的事务ID； 而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本；delete flag没有展示出来。</p>\n<ol start=\"2\">\n<li>undo log</li>\n</ol>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216123137282-729908975.png\" alt=\"image-20230216123135892\" loading=\"lazy\" class=\"φbp\"></p>\n<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录</p>\n<ol start=\"3\">\n<li>ReadView</li>\n</ol>\n<p>已提交读和可重复读的区别就在于它们生成ReadView的策略不同。</p>\n<p>ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。</p>\n<p>a) 如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。<br>\nb) 如果你要访问的记录版本的事务id为90,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。<br>\nc) 如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。</p>\n<p>这些记录都是去undo log 链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。</p>\n<ul>\n<li>举个例子，在已提交读隔离级别下：</li>\n</ul>\n<p>比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216123624151-840211725.png\" alt=\"image-20230216123622831\" loading=\"lazy\" class=\"φbp\"></p>\n<p>那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。</p>\n<p>那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。</p>\n<p>这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。</p>\n<p>那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216123927433-1643569494.png\" alt=\"image-20230216123926091\" loading=\"lazy\" class=\"φbp\"></p>\n<p>这时候版本链就是:</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216123957554-2120513921.png\" alt=\"image-20230216123956250\" loading=\"lazy\" class=\"φbp\"></p>\n<p>这时候之前那个select事务又执行了一次查询,要查询id为1的记录。</p>\n<p><strong>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView</strong>。</p>\n<ol>\n<li>如果你是已提交读隔离级别，这时候你会重新一个ReadView，那你的活动事务列表中的值就变了，变成了[110]。按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。</li>\n<li>如果你是可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！</li>\n</ol>\n<p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。</p>\n<h1 id=\"mysql-锁的类型有哪些呢？\">MySQL 锁的类型有哪些呢？<a title=\"#mysql-锁的类型有哪些呢？\" href=\"#mysql-锁的类型有哪些呢？\"></a></h1>\n<p><strong>说两个维度</strong>：</p>\n<ul>\n<li>共享锁(简称S锁)和排他锁(简称X锁)\n<ul>\n<li><strong>读锁</strong>是共享的，可以通过lock in share mode实现，这时候只能读不能写。</li>\n<li><strong>写锁</strong>是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。</li>\n</ul>\n</li>\n<li>表锁和行锁\n<ul>\n<li><strong>表锁</strong>会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。</li>\n<li><strong>行锁</strong>又可以分为乐观锁和悲观锁\n<ul>\n<li>悲观锁可以通过for update实现</li>\n<li>乐观锁则通过版本号实现。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>两个维度结合来看</strong>：</p>\n<ul>\n<li>共享锁(行锁):Shared Locks\n<ul>\n<li>读锁(s锁),多个事务对于同一数据可以共享访问,不能操作修改</li>\n<li>使用方法:\n<ul>\n<li>加锁:SELECT * FROM table WHERE id=1 LOCK IN SHARE MODE</li>\n<li>释锁:COMMIT/ROLLBACK</li>\n</ul>\n</li>\n<li>排他锁（行锁）：Exclusive Locks\n<ul>\n<li>写锁(X锁)，互斥锁/独占锁,事务获取了一个数据的X锁，其他事务就不能再获取该行的读锁和写锁（S锁、X锁），只有获取了该排他锁的事务是可以对数据行进行读取和修改</li>\n<li>使用方法:\n<ul>\n<li>DELETE/ UPDATE/ INSERT – 加锁</li>\n<li>SELECT * FROM table WHERE … FOR UPDATE – 加锁</li>\n<li>COMMIT/ROLLBACK – 释锁</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>意向共享锁(IS)\n<ul>\n<li>一个数据行加共享锁前必须先取得该表的IS锁，意向共享锁之间是可以相互兼容的 意向排它锁(IX) 一个数据行加排他锁前必须先取得该表的IX锁，意向排它锁之间是可以相互兼容的 意向锁(IS、IX)是InnoDB引擎操作数据之前自动加的，不需要用户干预; 意义： 当事务操作需要锁表时，只需判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li>\n<li>意向共享锁(IS锁)（表锁）：Intention Shared Locks\n<ul>\n<li>表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁 前必须先取得该表的IS锁。</li>\n</ul>\n</li>\n<li>意向排它锁(IX锁)（表锁）：Intention Exclusive Locks\n<ul>\n<li>表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他 锁前必须先取得该表的IX锁。、</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"你们数据量级多大？分库分表怎么做的？\">你们数据量级多大？分库分表怎么做的？<a title=\"#你们数据量级多大？分库分表怎么做的？\" href=\"#你们数据量级多大？分库分表怎么做的？\"></a></h1>\n<p>首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。</p>\n<ul>\n<li>垂直分库</li>\n</ul>\n<p>基于现在微服务拆分来说，都是已经做到了垂直分库了</p>\n<ul>\n<li>垂直分表</li>\n</ul>\n<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>\n<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216144225910-1427737638.png\" alt=\"image-20230216144224498\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li>水平分表</li>\n</ul>\n<p>首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单1000万，我们大部分的场景来源于C端，我们可以用user_id作为sharding_key，数据查询支持到最近3个月的订单，超过3个月的做归档处理，那么3个月的数据量就是9亿，可以分1024张表，那么每张表的数据大概就在100万左右。</p>\n<p>比如用户id为100，那我们都经过hash(100)，然后对1024取模，就可以落到对应的表上了。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230216144922706-1406400042.png\" alt=\"image-20230216144921238\" loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"那分表后的id怎么保证唯一性的呢？\">那分表后的ID怎么保证唯一性的呢？<a title=\"#那分表后的id怎么保证唯一性的呢？\" href=\"#那分表后的id怎么保证唯一性的呢？\"></a></h1>\n<p>因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：</p>\n<ul>\n<li>设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。</li>\n<li>分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种</li>\n<li>分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。</li>\n</ul>\n<h1 id=\"分表后非sharding_key的查询怎么处理呢？\">分表后非sharding_key的查询怎么处理呢？<a title=\"#分表后非sharding_key的查询怎么处理呢？\" href=\"#分表后非sharding_key的查询怎么处理呢？\"></a></h1>\n<ul>\n<li>可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过user_id去查询。</li>\n<li>大宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其它如es提供查询服务。</li>\n<li>数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Callable&lt;List&lt;User&gt;&gt;&gt; taskList = Lists.newArrayList();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">shardingIndex</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; shardingIndex &lt; <span class=\"hljs-number\">1024</span>; shardingIndex++) &#123;<br>    taskList.add(() -&gt; (userMapper.getProcessingAccountList(shardingIndex)));<br>&#125;<br>List&lt;ThirdAccountInfo&gt; list = <span class=\"hljs-literal\">null</span>;<br><span class=\"hljs-keyword\">try</span> &#123;<br>    list = taskExecutor.executeTask(taskList);<br>&#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>    <span class=\"hljs-comment\">//do something</span><br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaskExecutor</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> &lt;T&gt; List&lt;T&gt; <span class=\"hljs-title function_\">executeTask</span><span class=\"hljs-params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>        List&lt;T&gt; result = Lists.newArrayList();<br>        List&lt;Future&lt;T&gt;&gt; futures = ExecutorUtil.invokeAll(tasks);<br>        <span class=\"hljs-keyword\">for</span> (Future&lt;T&gt; future : futures) &#123;<br>            result.add(future.get());<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"mysql主从复制？\">MySQL主从复制？<a title=\"#mysql主从复制？\" href=\"#mysql主从复制？\"></a></h1>\n<p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p>\n<ul>\n<li>binlog 线程: 负责将主服务器上的数据更改写入二进制日志中。</li>\n<li>I/O 线程 : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>\n<li>SQL 线程 : 负责读取中继日志并重放其中的 SQL 语句。</li>\n</ul>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230217161140682-1749161635.png\" alt=\"image-20230217161139965\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"全同步复制\"><strong>全同步复制</strong><a title=\"#全同步复制\" href=\"#全同步复制\"></a></h2>\n<ul>\n<li>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</li>\n</ul>\n<h2 id=\"半同步复制\"><strong>半同步复制</strong><a title=\"#半同步复制\" href=\"#半同步复制\"></a></h2>\n<ul>\n<li>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</li>\n</ul>\n<h1 id=\"mysql主从的延迟怎么解决呢？\">MySQL主从的延迟怎么解决呢？<a title=\"#mysql主从的延迟怎么解决呢？\" href=\"#mysql主从的延迟怎么解决呢？\"></a></h1>\n<ul>\n<li>这个问题貌似真的是个无解的问题，只能是说自己来判断了，需要走主库的强制走主库查询。</li>\n</ul>\n<h1 id=\"mysql读写分离方案?\">MySQL读写分离方案?<a title=\"#mysql读写分离方案?\" href=\"#mysql读写分离方案?\"></a></h1>\n<ul>\n<li>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</li>\n</ul>\n<p>读写分离能提高性能的原因在于:</p>\n<ul>\n<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>\n<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>\n<li>增加冗余，提高可用性。</li>\n</ul>\n<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/2105804/202302/2105804-20230217161850879-67006089.png\" alt=\"image-20230217161850263\" loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"常用开发库知识体系详解","link":"2023/02/21/开发/开发之常用类库/01-常用开发库知识体系详解"},"next":{"title":"原理和SQL","link":"2023/02/15/面试题/数据库/原理和SQL"},"plink":"http://example.com/2023/02/15/面试题/数据库/MySQL/","toc":[{"id":"能说下myisam-和-innodb的区别吗？","title":"能说下myisam 和 innodb的区别吗？","index":"1"},{"id":"说下mysql的索引有哪些吧？","title":"说下MySQL的索引有哪些吧？","index":"2"},{"id":"什么是b+树？为什么b+树成为主要的sql数据库的索引实现？","title":"什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？","index":"3"},{"id":"那你知道什么是覆盖索引和回表吗？","title":"那你知道什么是覆盖索引和回表吗？","index":"4"},{"id":"什么是mvcc？-说说mysql实现mvcc的原理？","title":"什么是MVCC？ 说说MySQL实现MVCC的原理？","index":"5"},{"id":"mysql-锁的类型有哪些呢？","title":"MySQL 锁的类型有哪些呢？","index":"6"},{"id":"你们数据量级多大？分库分表怎么做的？","title":"你们数据量级多大？分库分表怎么做的？","index":"7"},{"id":"那分表后的id怎么保证唯一性的呢？","title":"那分表后的ID怎么保证唯一性的呢？","index":"8"},{"id":"分表后非sharding_key的查询怎么处理呢？","title":"分表后非sharding_key的查询怎么处理呢？","index":"9"},{"id":"mysql主从复制？","title":"MySQL主从复制？","index":"10","children":[{"id":"全同步复制","title":"全同步复制","index":"10.1"},{"id":"半同步复制","title":"半同步复制","index":"10.2"}]},{"id":"mysql主从的延迟怎么解决呢？","title":"MySQL主从的延迟怎么解决呢？","index":"11"},{"id":"mysql读写分离方案?","title":"MySQL读写分离方案?","index":"12"}],"reading_time":"4584 words in 31 min"}